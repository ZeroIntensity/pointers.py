from typing import TypeVar, Union

from ._pyapi import API_FUNCS, Func
from .base_pointers import BaseObjectPointer
from .bindings import (
    CharLike, PointerLike, StringLike, binding_base, make_char, make_string
)
from .std_structs import *
from .structure import StructPointer


def api_binding_base(data: Func, *args):
    func = data[0]

    if not func:
        name: str = data[2]
        minver = data[1]

        raise NotImplementedError(
            f"{name} is only supported on versions {data[1]}+"
            if minver
            else f"{name} is not supported on this version",
        )

    return binding_base(func, *args)


class DumbassError(Exception):
    """lmao"""


class _CallBase:
    def __init__(self):
        raise DumbassError


T = TypeVar("T")
PyObjectLike = Union[T, BaseObjectPointer[T]]


def _deref_maybe(ob: PyObjectLike[T]) -> T:
    if isinstance(ob, BaseObjectPointer):
        return ~ob
    return ob


# autogenerated
__all__ = (
    "PyAIter",
    "PyArg",
    "PyBool",
    "PyBuffer",
    "PyByteArray",
    "PyBytes",
    "PyCallIter",
    "PyCallable",
    "PyCapsule",
    "PyCodec",
    "PyComplex",
    "PyDescr",
    "PyDictProxy",
    "PyDict",
    "PyErr",
    "PyEval",
    "PyException",
    "PyFile",
    "PyFloat",
    "PyFrame",
    "PyFrozenSet",
    "PyGC",
    "PyGILState",
    "PyImport",
    "PyIndex",
    "PyInterpreterState",
    "PyIter",
    "PyList",
    "PyLong",
    "PyMapping",
    "PyMem",
    "PyMemoryView",
    "PyModuleDef",
    "PyModule",
    "PyNumber",
    "PyOS",
    "PyObject",
    "PySeqIter",
    "PySequence",
    "PySet",
    "PySlice",
    "PyState",
    "PyStructSequence",
    "PySys",
    "PyThreadState",
    "PyThread",
    "PyTuple",
    "PyType",
    "PyUnicodeDecodeError",
    "PyUnicodeEncodeError",
    "PyUnicodeTranslateError",
    "PyUnicode",
    "PyWeakref",
    "Py",
)


class PyAIter(_CallBase):
    """Namespace containing API functions prefixed with `PyAIter_`"""

    # PyAIter_Check
    @staticmethod
    def check(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyAIter_Check"], _deref_maybe(o))


class PyArg(_CallBase):
    """Namespace containing API functions prefixed with `PyArg_`"""

    # PyArg_VaParse
    @staticmethod
    def va_parse(args: PyObjectLike, format: StringLike, vargs: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyArg_VaParse"], _deref_maybe(args), make_string(format), vargs
        )

    # PyArg_VaParseTupleAndKeywords
    @staticmethod
    def va_parse_tuple_and_keywords(
        args: PyObjectLike,
        kw: PyObjectLike,
        format: StringLike,
        keywords: PointerLike,
        vargs: PointerLike,
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyArg_VaParseTupleAndKeywords"],
            _deref_maybe(args),
            _deref_maybe(kw),
            make_string(format),
            keywords,
            vargs,
        )


class PyBool(_CallBase):
    """Namespace containing API functions prefixed with `PyBool_`"""

    # PyBool_FromLong
    @staticmethod
    def from_long(v: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyBool_FromLong"], v)


class PyBuffer(_CallBase):
    """Namespace containing API functions prefixed with `PyBuffer_`"""

    # PyBuffer_FillContiguousStrides
    @staticmethod
    def fill_contiguous_strides(
        ndims: int,
        shape: PointerLike,
        strides: PointerLike,
        itemsize: int,
        order: CharLike,
    ) -> None:
        return api_binding_base(
            API_FUNCS["PyBuffer_FillContiguousStrides"],
            ndims,
            shape,
            strides,
            itemsize,
            make_char(order),
        )

    # PyBuffer_FillInfo
    @staticmethod
    def fill_info(
        view: StructPointer[Buffer],
        exporter: PyObjectLike,
        buf: PointerLike,
        len: int,
        readonly: int,
        flags: int,
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyBuffer_FillInfo"],
            view,
            _deref_maybe(exporter),
            buf,
            len,
            readonly,
            flags,
        )

    # PyBuffer_FromContiguous
    @staticmethod
    def from_contiguous(
        view: StructPointer[Buffer], buf: PointerLike, len: int, fort: CharLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyBuffer_FromContiguous"], view, buf, len, make_char(fort)
        )

    # PyBuffer_GetPointer
    @staticmethod
    def get_pointer(view: StructPointer[Buffer], indices: PointerLike) -> PointerLike:
        return api_binding_base(API_FUNCS["PyBuffer_GetPointer"], view, indices)

    # PyBuffer_IsContiguous
    @staticmethod
    def is_contiguous(view: StructPointer[Buffer], order: CharLike) -> int:
        return api_binding_base(
            API_FUNCS["PyBuffer_IsContiguous"], view, make_char(order)
        )

    # PyBuffer_Release
    @staticmethod
    def release(view: StructPointer[Buffer]) -> None:
        return api_binding_base(API_FUNCS["PyBuffer_Release"], view)

    # PyBuffer_SizeFromFormat
    @staticmethod
    def size_from_format(format: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyBuffer_SizeFromFormat"], make_string(format)
        )

    # PyBuffer_ToContiguous
    @staticmethod
    def to_contiguous(
        buf: PointerLike, src: StructPointer[Buffer], len: int, order: CharLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyBuffer_ToContiguous"], buf, src, len, make_char(order)
        )


class PyByteArray(_CallBase):
    """Namespace containing API functions prefixed with `PyByteArray_`"""

    # PyByteArray_AsString
    @staticmethod
    def as_string(bytearray: PyObjectLike) -> StringLike:
        return api_binding_base(
            API_FUNCS["PyByteArray_AsString"], _deref_maybe(bytearray)
        )

    # PyByteArray_Concat
    @staticmethod
    def concat(a: PyObjectLike, b: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyByteArray_Concat"], _deref_maybe(a), _deref_maybe(b)
        )

    # PyByteArray_FromObject
    @staticmethod
    def from_object(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyByteArray_FromObject"], _deref_maybe(o))

    # PyByteArray_FromStringAndSize
    @staticmethod
    def from_string_and_size(string: StringLike, len: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyByteArray_FromStringAndSize"], make_string(string), len
        )

    # PyByteArray_Resize
    @staticmethod
    def resize(bytearray: PyObjectLike, len: int) -> int:
        return api_binding_base(
            API_FUNCS["PyByteArray_Resize"], _deref_maybe(bytearray), len
        )

    # PyByteArray_Size
    @staticmethod
    def size(bytearray: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyByteArray_Size"], _deref_maybe(bytearray))


class PyBytes(_CallBase):
    """Namespace containing API functions prefixed with `PyBytes_`"""

    # PyBytes_AsString
    @staticmethod
    def as_string(o: PyObjectLike) -> StringLike:
        return api_binding_base(API_FUNCS["PyBytes_AsString"], _deref_maybe(o))

    # PyBytes_AsStringAndSize
    @staticmethod
    def as_string_and_size(
        obj: PyObjectLike, buffer: PointerLike, length: PointerLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyBytes_AsStringAndSize"], _deref_maybe(obj), buffer, length
        )

    # PyBytes_Concat
    @staticmethod
    def concat(bytes: PointerLike, newpart: PyObjectLike) -> None:
        return api_binding_base(
            API_FUNCS["PyBytes_Concat"], bytes, _deref_maybe(newpart)
        )

    # PyBytes_ConcatAndDel
    @staticmethod
    def concat_and_del(bytes: PointerLike, newpart: PyObjectLike) -> None:
        return api_binding_base(
            API_FUNCS["PyBytes_ConcatAndDel"], bytes, _deref_maybe(newpart)
        )

    # PyBytes_FromFormatV
    @staticmethod
    def from_format_v(format: StringLike, vargs: PointerLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyBytes_FromFormatV"], make_string(format), vargs
        )

    # PyBytes_FromObject
    @staticmethod
    def from_object(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyBytes_FromObject"], _deref_maybe(o))

    # PyBytes_FromString
    @staticmethod
    def from_string(v: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyBytes_FromString"], make_string(v))

    # PyBytes_FromStringAndSize
    @staticmethod
    def from_string_and_size(v: StringLike, len: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyBytes_FromStringAndSize"], make_string(v), len
        )

    # PyBytes_Size
    @staticmethod
    def size(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyBytes_Size"], _deref_maybe(o))


class PyCallIter(_CallBase):
    """Namespace containing API functions prefixed with `PyCallIter_`"""

    # PyCallIter_New
    @staticmethod
    def new(callable: PyObjectLike, sentinel: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCallIter_New"], _deref_maybe(callable), _deref_maybe(sentinel)
        )


class PyCallable(_CallBase):
    """Namespace containing API functions prefixed with `PyCallable_`"""

    # PyCallable_Check
    @staticmethod
    def check(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyCallable_Check"], _deref_maybe(o))


class PyCapsule(_CallBase):
    """Namespace containing API functions prefixed with `PyCapsule_`"""

    # PyCapsule_GetContext
    @staticmethod
    def get_context(capsule: PyObjectLike) -> PointerLike:
        return api_binding_base(
            API_FUNCS["PyCapsule_GetContext"], _deref_maybe(capsule)
        )

    # PyCapsule_GetDestructor
    @staticmethod
    def get_destructor(capsule: PyObjectLike) -> PointerLike:
        return api_binding_base(
            API_FUNCS["PyCapsule_GetDestructor"], _deref_maybe(capsule)
        )

    # PyCapsule_GetName
    @staticmethod
    def get_name(capsule: PyObjectLike) -> StringLike:
        return api_binding_base(API_FUNCS["PyCapsule_GetName"], _deref_maybe(capsule))

    # PyCapsule_GetPointer
    @staticmethod
    def get_pointer(capsule: PyObjectLike, name: StringLike) -> PointerLike:
        return api_binding_base(
            API_FUNCS["PyCapsule_GetPointer"], _deref_maybe(capsule), make_string(name)
        )

    # PyCapsule_Import
    @staticmethod
    def import_(name: StringLike, no_block: int) -> PointerLike:
        return api_binding_base(
            API_FUNCS["PyCapsule_Import"], make_string(name), no_block
        )

    # PyCapsule_IsValid
    @staticmethod
    def is_valid(capsule: PyObjectLike, name: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyCapsule_IsValid"], _deref_maybe(capsule), make_string(name)
        )

    # PyCapsule_New
    @staticmethod
    def new(
        pointer: PointerLike, name: StringLike, destructor: PointerLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCapsule_New"], pointer, make_string(name), destructor
        )

    # PyCapsule_SetContext
    @staticmethod
    def set_context(capsule: PyObjectLike, context: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyCapsule_SetContext"], _deref_maybe(capsule), context
        )

    # PyCapsule_SetDestructor
    @staticmethod
    def set_destructor(capsule: PyObjectLike, destructor: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyCapsule_SetDestructor"], _deref_maybe(capsule), destructor
        )

    # PyCapsule_SetName
    @staticmethod
    def set_name(capsule: PyObjectLike, name: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyCapsule_SetName"], _deref_maybe(capsule), make_string(name)
        )

    # PyCapsule_SetPointer
    @staticmethod
    def set_pointer(capsule: PyObjectLike, pointer: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyCapsule_SetPointer"], _deref_maybe(capsule), pointer
        )


class PyCodec(_CallBase):
    """Namespace containing API functions prefixed with `PyCodec_`"""

    # PyCodec_BackslashReplaceErrors
    @staticmethod
    def backslash_replace_errors(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCodec_BackslashReplaceErrors"], _deref_maybe(exc)
        )

    # PyCodec_Decode
    @staticmethod
    def decode(
        object: PyObjectLike, encoding: StringLike, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCodec_Decode"],
            _deref_maybe(object),
            make_string(encoding),
            make_string(errors),
        )

    # PyCodec_Decoder
    @staticmethod
    def decoder(encoding: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyCodec_Decoder"], make_string(encoding))

    # PyCodec_Encode
    @staticmethod
    def encode(
        object: PyObjectLike, encoding: StringLike, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCodec_Encode"],
            _deref_maybe(object),
            make_string(encoding),
            make_string(errors),
        )

    # PyCodec_Encoder
    @staticmethod
    def encoder(encoding: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyCodec_Encoder"], make_string(encoding))

    # PyCodec_IgnoreErrors
    @staticmethod
    def ignore_errors(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyCodec_IgnoreErrors"], _deref_maybe(exc))

    # PyCodec_IncrementalDecoder
    @staticmethod
    def incremental_decoder(encoding: StringLike, errors: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCodec_IncrementalDecoder"],
            make_string(encoding),
            make_string(errors),
        )

    # PyCodec_IncrementalEncoder
    @staticmethod
    def incremental_encoder(encoding: StringLike, errors: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCodec_IncrementalEncoder"],
            make_string(encoding),
            make_string(errors),
        )

    # PyCodec_KnownEncoding
    @staticmethod
    def known_encoding(encoding: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyCodec_KnownEncoding"], make_string(encoding)
        )

    # PyCodec_LookupError
    @staticmethod
    def lookup_error(name: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyCodec_LookupError"], make_string(name))

    # PyCodec_NameReplaceErrors
    @staticmethod
    def name_replace_errors(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCodec_NameReplaceErrors"], _deref_maybe(exc)
        )

    # PyCodec_Register
    @staticmethod
    def register(search_function: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyCodec_Register"], _deref_maybe(search_function)
        )

    # PyCodec_RegisterError
    @staticmethod
    def register_error(name: StringLike, error: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyCodec_RegisterError"], make_string(name), _deref_maybe(error)
        )

    # PyCodec_ReplaceErrors
    @staticmethod
    def replace_errors(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyCodec_ReplaceErrors"], _deref_maybe(exc))

    # PyCodec_StreamReader
    @staticmethod
    def stream_reader(
        encoding: StringLike, stream: PyObjectLike, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCodec_StreamReader"],
            make_string(encoding),
            _deref_maybe(stream),
            make_string(errors),
        )

    # PyCodec_StreamWriter
    @staticmethod
    def stream_writer(
        encoding: StringLike, stream: PyObjectLike, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCodec_StreamWriter"],
            make_string(encoding),
            _deref_maybe(stream),
            make_string(errors),
        )

    # PyCodec_StrictErrors
    @staticmethod
    def strict_errors(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyCodec_StrictErrors"], _deref_maybe(exc))

    # PyCodec_Unregister
    @staticmethod
    def unregister(search_function: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyCodec_Unregister"], _deref_maybe(search_function)
        )

    # PyCodec_XMLCharRefReplaceErrors
    @staticmethod
    def x_m_l_char_ref_replace_errors(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyCodec_XMLCharRefReplaceErrors"], _deref_maybe(exc)
        )


class PyComplex(_CallBase):
    """Namespace containing API functions prefixed with `PyComplex_`"""

    # PyComplex_FromDoubles
    @staticmethod
    def from_doubles(real: int, imag: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyComplex_FromDoubles"], real, imag)

    # PyComplex_ImagAsDouble
    @staticmethod
    def imag_as_double(op: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyComplex_ImagAsDouble"], _deref_maybe(op))

    # PyComplex_RealAsDouble
    @staticmethod
    def real_as_double(op: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyComplex_RealAsDouble"], _deref_maybe(op))


class PyDescr(_CallBase):
    """Namespace containing API functions prefixed with `PyDescr_`"""

    # PyDescr_NewClassMethod
    @staticmethod
    def new_class_method(type: StructPointer[TypeObject]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyDescr_NewClassMethod"], type)

    # PyDescr_NewGetSet
    @staticmethod
    def new_get_set(type: StructPointer[TypeObject]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyDescr_NewGetSet"], type)

    # PyDescr_NewMember
    @staticmethod
    def new_member(type: StructPointer[TypeObject]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyDescr_NewMember"], type)

    # PyDescr_NewMethod
    @staticmethod
    def new_method(type: StructPointer[TypeObject]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyDescr_NewMethod"], type)


class PyDictProxy(_CallBase):
    """Namespace containing API functions prefixed with `PyDictProxy_`"""

    # PyDictProxy_New
    @staticmethod
    def new(mapping: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyDictProxy_New"], _deref_maybe(mapping))


class PyDict(_CallBase):
    """Namespace containing API functions prefixed with `PyDict_`"""

    # PyDict_Clear
    @staticmethod
    def clear(p: PyObjectLike) -> None:
        return api_binding_base(API_FUNCS["PyDict_Clear"], _deref_maybe(p))

    # PyDict_Contains
    @staticmethod
    def contains(p: PyObjectLike, key: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyDict_Contains"], _deref_maybe(p), _deref_maybe(key)
        )

    # PyDict_Copy
    @staticmethod
    def copy(p: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyDict_Copy"], _deref_maybe(p))

    # PyDict_DelItem
    @staticmethod
    def del_item(p: PyObjectLike, key: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyDict_DelItem"], _deref_maybe(p), _deref_maybe(key)
        )

    # PyDict_DelItemString
    @staticmethod
    def del_item_string(p: PyObjectLike, key: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyDict_DelItemString"], _deref_maybe(p), make_string(key)
        )

    # PyDict_GetItem
    @staticmethod
    def get_item(p: PyObjectLike, key: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyDict_GetItem"], _deref_maybe(p), _deref_maybe(key)
        )

    # PyDict_GetItemString
    @staticmethod
    def get_item_string(p: PyObjectLike, key: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyDict_GetItemString"], _deref_maybe(p), make_string(key)
        )

    # PyDict_GetItemWithError
    @staticmethod
    def get_item_with_error(p: PyObjectLike, key: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyDict_GetItemWithError"], _deref_maybe(p), _deref_maybe(key)
        )

    # PyDict_Items
    @staticmethod
    def items(p: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyDict_Items"], _deref_maybe(p))

    # PyDict_Keys
    @staticmethod
    def keys(p: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyDict_Keys"], _deref_maybe(p))

    # PyDict_Merge
    @staticmethod
    def merge(a: PyObjectLike, b: PyObjectLike, override: int) -> int:
        return api_binding_base(
            API_FUNCS["PyDict_Merge"], _deref_maybe(a), _deref_maybe(b), override
        )

    # PyDict_MergeFromSeq2
    @staticmethod
    def merge_from_seq2(a: PyObjectLike, seq2: PyObjectLike, override: int) -> int:
        return api_binding_base(
            API_FUNCS["PyDict_MergeFromSeq2"],
            _deref_maybe(a),
            _deref_maybe(seq2),
            override,
        )

    # PyDict_New
    @staticmethod
    def new() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyDict_New"],
        )

    # PyDict_Next
    @staticmethod
    def next(
        p: PyObjectLike, ppos: PointerLike, pkey: PointerLike, pvalue: PointerLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyDict_Next"], _deref_maybe(p), ppos, pkey, pvalue
        )

    # PyDict_SetItem
    @staticmethod
    def set_item(p: PyObjectLike, key: PyObjectLike, val: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyDict_SetItem"],
            _deref_maybe(p),
            _deref_maybe(key),
            _deref_maybe(val),
        )

    # PyDict_SetItemString
    @staticmethod
    def set_item_string(p: PyObjectLike, key: StringLike, val: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyDict_SetItemString"],
            _deref_maybe(p),
            make_string(key),
            _deref_maybe(val),
        )

    # PyDict_Size
    @staticmethod
    def size(p: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyDict_Size"], _deref_maybe(p))

    # PyDict_Update
    @staticmethod
    def update(a: PyObjectLike, b: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyDict_Update"], _deref_maybe(a), _deref_maybe(b)
        )

    # PyDict_Values
    @staticmethod
    def values(p: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyDict_Values"], _deref_maybe(p))


class PyErr(_CallBase):
    """Namespace containing API functions prefixed with `PyErr_`"""

    # PyErr_BadArgument
    @staticmethod
    def bad_argument() -> int:
        return api_binding_base(
            API_FUNCS["PyErr_BadArgument"],
        )

    # PyErr_BadInternalCall
    @staticmethod
    def bad_internal_call() -> None:
        return api_binding_base(
            API_FUNCS["PyErr_BadInternalCall"],
        )

    # PyErr_CheckSignals
    @staticmethod
    def check_signals() -> int:
        return api_binding_base(
            API_FUNCS["PyErr_CheckSignals"],
        )

    # PyErr_Clear
    @staticmethod
    def clear() -> None:
        return api_binding_base(
            API_FUNCS["PyErr_Clear"],
        )

    # PyErr_ExceptionMatches
    @staticmethod
    def exception_matches(exc: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyErr_ExceptionMatches"], _deref_maybe(exc))

    # PyErr_Fetch
    @staticmethod
    def fetch(ptype: PointerLike, pvalue: PointerLike, ptraceback: PointerLike) -> None:
        return api_binding_base(API_FUNCS["PyErr_Fetch"], ptype, pvalue, ptraceback)

    # PyErr_FormatV
    @staticmethod
    def format_v(
        exception: PyObjectLike, format: StringLike, vargs: PointerLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_FormatV"],
            _deref_maybe(exception),
            make_string(format),
            vargs,
        )

    # PyErr_GetExcInfo
    @staticmethod
    def get_exc_info(
        ptype: PointerLike, pvalue: PointerLike, ptraceback: PointerLike
    ) -> None:
        return api_binding_base(
            API_FUNCS["PyErr_GetExcInfo"], ptype, pvalue, ptraceback
        )

    # PyErr_GivenExceptionMatches
    @staticmethod
    def given_exception_matches(given: PyObjectLike, exc: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyErr_GivenExceptionMatches"],
            _deref_maybe(given),
            _deref_maybe(exc),
        )

    # PyErr_NewException
    @staticmethod
    def new_exception(
        name: StringLike, base: PyObjectLike, dict: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_NewException"],
            make_string(name),
            _deref_maybe(base),
            _deref_maybe(dict),
        )

    # PyErr_NewExceptionWithDoc
    @staticmethod
    def new_exception_with_doc(
        name: StringLike, doc: StringLike, base: PyObjectLike, dict: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_NewExceptionWithDoc"],
            make_string(name),
            make_string(doc),
            _deref_maybe(base),
            _deref_maybe(dict),
        )

    # PyErr_NoMemory
    @staticmethod
    def no_memory() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_NoMemory"],
        )

    # PyErr_NormalizeException
    @staticmethod
    def normalize_exception(
        exc: PointerLike, val: PointerLike, tb: PointerLike
    ) -> None:
        return api_binding_base(API_FUNCS["PyErr_NormalizeException"], exc, val, tb)

    # PyErr_Occurred
    @staticmethod
    def occurred() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_Occurred"],
        )

    # PyErr_Print
    @staticmethod
    def print() -> None:
        return api_binding_base(
            API_FUNCS["PyErr_Print"],
        )

    # PyErr_PrintEx
    @staticmethod
    def print_ex(set_sys_last_vars: int) -> None:
        return api_binding_base(API_FUNCS["PyErr_PrintEx"], set_sys_last_vars)

    # PyErr_Restore
    @staticmethod
    def restore(
        type: PyObjectLike, value: PyObjectLike, traceback: PyObjectLike
    ) -> None:
        return api_binding_base(
            API_FUNCS["PyErr_Restore"],
            _deref_maybe(type),
            _deref_maybe(value),
            _deref_maybe(traceback),
        )

    # PyErr_SetExcInfo
    @staticmethod
    def set_exc_info(
        type: PyObjectLike, value: PyObjectLike, traceback: PyObjectLike
    ) -> None:
        return api_binding_base(
            API_FUNCS["PyErr_SetExcInfo"],
            _deref_maybe(type),
            _deref_maybe(value),
            _deref_maybe(traceback),
        )

    # PyErr_SetFromErrno
    @staticmethod
    def set_from_errno(type: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyErr_SetFromErrno"], _deref_maybe(type))

    # PyErr_SetFromErrnoWithFilename
    @staticmethod
    def set_from_errno_with_filename(
        type: PyObjectLike, filename: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_SetFromErrnoWithFilename"],
            _deref_maybe(type),
            make_string(filename),
        )

    # PyErr_SetFromErrnoWithFilenameObject
    @staticmethod
    def set_from_errno_with_filename_object(
        type: PyObjectLike, filenameObject: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_SetFromErrnoWithFilenameObject"],
            _deref_maybe(type),
            _deref_maybe(filenameObject),
        )

    # PyErr_SetFromErrnoWithFilenameObjects
    @staticmethod
    def set_from_errno_with_filename_objects(
        type: PyObjectLike, filenameObject: PyObjectLike, filenameObject2: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_SetFromErrnoWithFilenameObjects"],
            _deref_maybe(type),
            _deref_maybe(filenameObject),
            _deref_maybe(filenameObject2),
        )

    # PyErr_SetImportError
    @staticmethod
    def set_import_error(
        msg: PyObjectLike, name: PyObjectLike, path: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_SetImportError"],
            _deref_maybe(msg),
            _deref_maybe(name),
            _deref_maybe(path),
        )

    # PyErr_SetImportErrorSubclass
    @staticmethod
    def set_import_error_subclass(
        exception: PyObjectLike,
        msg: PyObjectLike,
        name: PyObjectLike,
        path: PyObjectLike,
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyErr_SetImportErrorSubclass"],
            _deref_maybe(exception),
            _deref_maybe(msg),
            _deref_maybe(name),
            _deref_maybe(path),
        )

    # PyErr_SetInterrupt
    @staticmethod
    def set_interrupt() -> None:
        return api_binding_base(
            API_FUNCS["PyErr_SetInterrupt"],
        )

    # PyErr_SetInterruptEx
    @staticmethod
    def set_interrupt_ex(signum: int) -> int:
        return api_binding_base(API_FUNCS["PyErr_SetInterruptEx"], signum)

    # PyErr_SetNone
    @staticmethod
    def set_none(type: PyObjectLike) -> None:
        return api_binding_base(API_FUNCS["PyErr_SetNone"], _deref_maybe(type))

    # PyErr_SetObject
    @staticmethod
    def set_object(type: PyObjectLike, value: PyObjectLike) -> None:
        return api_binding_base(
            API_FUNCS["PyErr_SetObject"], _deref_maybe(type), _deref_maybe(value)
        )

    # PyErr_SetString
    @staticmethod
    def set_string(type: PyObjectLike, message: StringLike) -> None:
        return api_binding_base(
            API_FUNCS["PyErr_SetString"], _deref_maybe(type), make_string(message)
        )

    # PyErr_SyntaxLocation
    @staticmethod
    def syntax_location(filename: StringLike, lineno: int) -> None:
        return api_binding_base(
            API_FUNCS["PyErr_SyntaxLocation"], make_string(filename), lineno
        )

    # PyErr_SyntaxLocationEx
    @staticmethod
    def syntax_location_ex(filename: StringLike, lineno: int, col_offset: int) -> None:
        return api_binding_base(
            API_FUNCS["PyErr_SyntaxLocationEx"],
            make_string(filename),
            lineno,
            col_offset,
        )

    # PyErr_WarnEx
    @staticmethod
    def warn_ex(category: PyObjectLike, message: StringLike, stack_level: int) -> int:
        return api_binding_base(
            API_FUNCS["PyErr_WarnEx"],
            _deref_maybe(category),
            make_string(message),
            stack_level,
        )

    # PyErr_WarnExplicit
    @staticmethod
    def warn_explicit(
        category: PyObjectLike,
        message: StringLike,
        filename: StringLike,
        lineno: int,
        module: StringLike,
        registry: PyObjectLike,
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyErr_WarnExplicit"],
            _deref_maybe(category),
            make_string(message),
            make_string(filename),
            lineno,
            make_string(module),
            _deref_maybe(registry),
        )

    # PyErr_WriteUnraisable
    @staticmethod
    def write_unraisable(obj: PyObjectLike) -> None:
        return api_binding_base(API_FUNCS["PyErr_WriteUnraisable"], _deref_maybe(obj))


class PyEval(_CallBase):
    """Namespace containing API functions prefixed with `PyEval_`"""

    # PyEval_AcquireLock
    @staticmethod
    def acquire_lock() -> None:
        return api_binding_base(
            API_FUNCS["PyEval_AcquireLock"],
        )

    # PyEval_AcquireThread
    @staticmethod
    def acquire_thread(tstate: StructPointer[ThreadState]) -> None:
        return api_binding_base(API_FUNCS["PyEval_AcquireThread"], tstate)

    # PyEval_EvalCode
    @staticmethod
    def eval_code(
        co: PyObjectLike, globals: PyObjectLike, locals: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyEval_EvalCode"],
            _deref_maybe(co),
            _deref_maybe(globals),
            _deref_maybe(locals),
        )

    # PyEval_EvalCodeEx
    @staticmethod
    def eval_code_ex(
        co: PyObjectLike,
        globals: PyObjectLike,
        locals: PyObjectLike,
        args: PointerLike,
        argcount: int,
        kws: PointerLike,
        kwcount: int,
        defs: PointerLike,
        defcount: int,
        kwdefs: PyObjectLike,
        closure: PyObjectLike,
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyEval_EvalCodeEx"],
            _deref_maybe(co),
            _deref_maybe(globals),
            _deref_maybe(locals),
            args,
            argcount,
            kws,
            kwcount,
            defs,
            defcount,
            _deref_maybe(kwdefs),
            _deref_maybe(closure),
        )

    # PyEval_EvalFrame
    @staticmethod
    def eval_frame(f: StructPointer[FrameObject]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyEval_EvalFrame"], f)

    # PyEval_EvalFrameEx
    @staticmethod
    def eval_frame_ex(f: StructPointer[FrameObject], throwflag: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyEval_EvalFrameEx"], f, throwflag)

    # PyEval_GetBuiltins
    @staticmethod
    def get_builtins() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyEval_GetBuiltins"],
        )

    # PyEval_GetFrame
    @staticmethod
    def get_frame() -> StructPointer[FrameObject]:
        return api_binding_base(
            API_FUNCS["PyEval_GetFrame"],
        )

    # PyEval_GetFuncDesc
    @staticmethod
    def get_func_desc(func: PyObjectLike) -> StringLike:
        return api_binding_base(API_FUNCS["PyEval_GetFuncDesc"], _deref_maybe(func))

    # PyEval_GetFuncName
    @staticmethod
    def get_func_name(func: PyObjectLike) -> StringLike:
        return api_binding_base(API_FUNCS["PyEval_GetFuncName"], _deref_maybe(func))

    # PyEval_GetGlobals
    @staticmethod
    def get_globals() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyEval_GetGlobals"],
        )

    # PyEval_GetLocals
    @staticmethod
    def get_locals() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyEval_GetLocals"],
        )

    # PyEval_InitThreads
    @staticmethod
    def init_threads() -> None:
        return api_binding_base(
            API_FUNCS["PyEval_InitThreads"],
        )

    # PyEval_ReleaseLock
    @staticmethod
    def release_lock() -> None:
        return api_binding_base(
            API_FUNCS["PyEval_ReleaseLock"],
        )

    # PyEval_ReleaseThread
    @staticmethod
    def release_thread(tstate: StructPointer[ThreadState]) -> None:
        return api_binding_base(API_FUNCS["PyEval_ReleaseThread"], tstate)

    # PyEval_RestoreThread
    @staticmethod
    def restore_thread(tstate: StructPointer[ThreadState]) -> None:
        return api_binding_base(API_FUNCS["PyEval_RestoreThread"], tstate)

    # PyEval_SaveThread
    @staticmethod
    def save_thread() -> StructPointer[ThreadState]:
        return api_binding_base(
            API_FUNCS["PyEval_SaveThread"],
        )

    # PyEval_ThreadsInitialized
    @staticmethod
    def threads_initialized() -> int:
        return api_binding_base(
            API_FUNCS["PyEval_ThreadsInitialized"],
        )


class PyException(_CallBase):
    """Namespace containing API functions prefixed with `PyException_`"""

    # PyException_GetCause
    @staticmethod
    def get_cause(ex: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyException_GetCause"], _deref_maybe(ex))

    # PyException_GetContext
    @staticmethod
    def get_context(ex: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyException_GetContext"], _deref_maybe(ex))

    # PyException_GetTraceback
    @staticmethod
    def get_traceback(ex: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyException_GetTraceback"], _deref_maybe(ex))

    # PyException_SetCause
    @staticmethod
    def set_cause(ex: PyObjectLike, cause: PyObjectLike) -> None:
        return api_binding_base(
            API_FUNCS["PyException_SetCause"], _deref_maybe(ex), _deref_maybe(cause)
        )

    # PyException_SetContext
    @staticmethod
    def set_context(ex: PyObjectLike, ctx: PyObjectLike) -> None:
        return api_binding_base(
            API_FUNCS["PyException_SetContext"], _deref_maybe(ex), _deref_maybe(ctx)
        )

    # PyException_SetTraceback
    @staticmethod
    def set_traceback(ex: PyObjectLike, tb: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyException_SetTraceback"], _deref_maybe(ex), _deref_maybe(tb)
        )


class PyFile(_CallBase):
    """Namespace containing API functions prefixed with `PyFile_`"""

    # PyFile_FromFd
    @staticmethod
    def from_fd(
        fd: int,
        name: StringLike,
        mode: StringLike,
        buffering: int,
        encoding: StringLike,
        errors: StringLike,
        newline: StringLike,
        closefd: int,
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyFile_FromFd"],
            fd,
            make_string(name),
            make_string(mode),
            buffering,
            make_string(encoding),
            make_string(errors),
            make_string(newline),
            closefd,
        )

    # PyFile_GetLine
    @staticmethod
    def get_line(p: PyObjectLike, n: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyFile_GetLine"], _deref_maybe(p), n)

    # PyFile_WriteObject
    @staticmethod
    def write_object(obj: PyObjectLike, p: PyObjectLike, flags: int) -> int:
        return api_binding_base(
            API_FUNCS["PyFile_WriteObject"], _deref_maybe(obj), _deref_maybe(p), flags
        )

    # PyFile_WriteString
    @staticmethod
    def write_string(s: StringLike, p: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyFile_WriteString"], make_string(s), _deref_maybe(p)
        )


class PyFloat(_CallBase):
    """Namespace containing API functions prefixed with `PyFloat_`"""

    # PyFloat_AsDouble
    @staticmethod
    def as_double(pyfloat: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyFloat_AsDouble"], _deref_maybe(pyfloat))

    # PyFloat_FromDouble
    @staticmethod
    def from_double(v: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyFloat_FromDouble"], v)

    # PyFloat_FromString
    @staticmethod
    def from_string(str: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyFloat_FromString"], _deref_maybe(str))

    # PyFloat_GetInfo
    @staticmethod
    def get_info() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyFloat_GetInfo"],
        )

    # PyFloat_GetMax
    @staticmethod
    def get_max() -> int:
        return api_binding_base(
            API_FUNCS["PyFloat_GetMax"],
        )

    # PyFloat_GetMin
    @staticmethod
    def get_min() -> int:
        return api_binding_base(
            API_FUNCS["PyFloat_GetMin"],
        )


class PyFrame(_CallBase):
    """Namespace containing API functions prefixed with `PyFrame_`"""

    # PyFrame_GetCode
    @staticmethod
    def get_code(frame: StructPointer[FrameObject]) -> StructPointer[CodeObject]:
        return api_binding_base(API_FUNCS["PyFrame_GetCode"], frame)

    # PyFrame_GetLineNumber
    @staticmethod
    def get_line_number(frame: StructPointer[FrameObject]) -> int:
        return api_binding_base(API_FUNCS["PyFrame_GetLineNumber"], frame)


class PyFrozenSet(_CallBase):
    """Namespace containing API functions prefixed with `PyFrozenSet_`"""

    # PyFrozenSet_New
    @staticmethod
    def new(iterable: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyFrozenSet_New"], _deref_maybe(iterable))


class PyGC(_CallBase):
    """Namespace containing API functions prefixed with `PyGC_`"""

    # PyGC_Collect
    @staticmethod
    def collect() -> int:
        return api_binding_base(
            API_FUNCS["PyGC_Collect"],
        )

    # PyGC_Disable
    @staticmethod
    def disable() -> int:
        return api_binding_base(
            API_FUNCS["PyGC_Disable"],
        )

    # PyGC_Enable
    @staticmethod
    def enable() -> int:
        return api_binding_base(
            API_FUNCS["PyGC_Enable"],
        )

    # PyGC_IsEnabled
    @staticmethod
    def is_enabled() -> int:
        return api_binding_base(
            API_FUNCS["PyGC_IsEnabled"],
        )


class PyGILState(_CallBase):
    """Namespace containing API functions prefixed with `PyGILState_`"""

    # PyGILState_Ensure
    @staticmethod
    def ensure() -> PointerLike:
        return api_binding_base(
            API_FUNCS["PyGILState_Ensure"],
        )

    # PyGILState_GetThisThreadState
    @staticmethod
    def get_this_thread_state() -> StructPointer[ThreadState]:
        return api_binding_base(
            API_FUNCS["PyGILState_GetThisThreadState"],
        )


class PyImport(_CallBase):
    """Namespace containing API functions prefixed with `PyImport_`"""

    # PyImport_AddModule
    @staticmethod
    def add_module(name: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyImport_AddModule"], make_string(name))

    # PyImport_AddModuleObject
    @staticmethod
    def add_module_object(name: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyImport_AddModuleObject"], _deref_maybe(name)
        )

    # PyImport_ExecCodeModule
    @staticmethod
    def exec_code_module(name: StringLike, co: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyImport_ExecCodeModule"], make_string(name), _deref_maybe(co)
        )

    # PyImport_ExecCodeModuleEx
    @staticmethod
    def exec_code_module_ex(
        name: StringLike, co: PyObjectLike, pathname: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyImport_ExecCodeModuleEx"],
            make_string(name),
            _deref_maybe(co),
            make_string(pathname),
        )

    # PyImport_ExecCodeModuleObject
    @staticmethod
    def exec_code_module_object(
        name: PyObjectLike,
        co: PyObjectLike,
        pathname: PyObjectLike,
        cpathname: PyObjectLike,
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyImport_ExecCodeModuleObject"],
            _deref_maybe(name),
            _deref_maybe(co),
            _deref_maybe(pathname),
            _deref_maybe(cpathname),
        )

    # PyImport_ExecCodeModuleWithPathnames
    @staticmethod
    def exec_code_module_with_pathnames(
        name: StringLike, co: PyObjectLike, pathname: StringLike, cpathname: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyImport_ExecCodeModuleWithPathnames"],
            make_string(name),
            _deref_maybe(co),
            make_string(pathname),
            make_string(cpathname),
        )

    # PyImport_GetImporter
    @staticmethod
    def get_importer(path: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyImport_GetImporter"], _deref_maybe(path))

    # PyImport_GetMagicNumber
    @staticmethod
    def get_magic_number() -> int:
        return api_binding_base(
            API_FUNCS["PyImport_GetMagicNumber"],
        )

    # PyImport_GetMagicTag
    @staticmethod
    def get_magic_tag() -> StringLike:
        return api_binding_base(
            API_FUNCS["PyImport_GetMagicTag"],
        )

    # PyImport_GetModule
    @staticmethod
    def get_module(name: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyImport_GetModule"], _deref_maybe(name))

    # PyImport_GetModuleDict
    @staticmethod
    def get_module_dict() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyImport_GetModuleDict"],
        )

    # PyImport_Import
    @staticmethod
    def import_(name: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyImport_Import"], _deref_maybe(name))

    # PyImport_ImportFrozenModule
    @staticmethod
    def import_frozen_module(name: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyImport_ImportFrozenModule"], make_string(name)
        )

    # PyImport_ImportFrozenModuleObject
    @staticmethod
    def import_frozen_module_object(name: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyImport_ImportFrozenModuleObject"], _deref_maybe(name)
        )

    # PyImport_ImportModule
    @staticmethod
    def import_module(name: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyImport_ImportModule"], make_string(name))

    # PyImport_ImportModuleLevel
    @staticmethod
    def import_module_level(
        name: StringLike,
        globals: PyObjectLike,
        locals: PyObjectLike,
        fromlist: PyObjectLike,
        level: int,
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyImport_ImportModuleLevel"],
            make_string(name),
            _deref_maybe(globals),
            _deref_maybe(locals),
            _deref_maybe(fromlist),
            level,
        )

    # PyImport_ImportModuleLevelObject
    @staticmethod
    def import_module_level_object(
        name: PyObjectLike,
        globals: PyObjectLike,
        locals: PyObjectLike,
        fromlist: PyObjectLike,
        level: int,
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyImport_ImportModuleLevelObject"],
            _deref_maybe(name),
            _deref_maybe(globals),
            _deref_maybe(locals),
            _deref_maybe(fromlist),
            level,
        )

    # PyImport_ImportModuleNoBlock
    @staticmethod
    def import_module_no_block(name: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyImport_ImportModuleNoBlock"], make_string(name)
        )

    # PyImport_ReloadModule
    @staticmethod
    def reload_module(m: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyImport_ReloadModule"], _deref_maybe(m))


class PyIndex(_CallBase):
    """Namespace containing API functions prefixed with `PyIndex_`"""

    # PyIndex_Check
    @staticmethod
    def check(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyIndex_Check"], _deref_maybe(o))


class PyInterpreterState(_CallBase):
    """Namespace containing API functions prefixed with `PyInterpreterState_`"""

    # PyInterpreterState_Clear
    @staticmethod
    def clear(interp: StructPointer[InterpreterState]) -> None:
        return api_binding_base(API_FUNCS["PyInterpreterState_Clear"], interp)

    # PyInterpreterState_Delete
    @staticmethod
    def delete(interp: StructPointer[InterpreterState]) -> None:
        return api_binding_base(API_FUNCS["PyInterpreterState_Delete"], interp)

    # PyInterpreterState_Get
    @staticmethod
    def get() -> StructPointer[InterpreterState]:
        return api_binding_base(
            API_FUNCS["PyInterpreterState_Get"],
        )

    # PyInterpreterState_GetDict
    @staticmethod
    def get_dict(interp: StructPointer[InterpreterState]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyInterpreterState_GetDict"], interp)

    # PyInterpreterState_GetID
    @staticmethod
    def get_i_d(interp: StructPointer[InterpreterState]) -> int:
        return api_binding_base(API_FUNCS["PyInterpreterState_GetID"], interp)

    # PyInterpreterState_New
    @staticmethod
    def new() -> StructPointer[InterpreterState]:
        return api_binding_base(
            API_FUNCS["PyInterpreterState_New"],
        )


class PyIter(_CallBase):
    """Namespace containing API functions prefixed with `PyIter_`"""

    # PyIter_Check
    @staticmethod
    def check(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyIter_Check"], _deref_maybe(o))

    # PyIter_Next
    @staticmethod
    def next(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyIter_Next"], _deref_maybe(o))


class PyList(_CallBase):
    """Namespace containing API functions prefixed with `PyList_`"""

    # PyList_Append
    @staticmethod
    def append(list: PyObjectLike, item: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyList_Append"], _deref_maybe(list), _deref_maybe(item)
        )

    # PyList_AsTuple
    @staticmethod
    def as_tuple(list: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyList_AsTuple"], _deref_maybe(list))

    # PyList_GetItem
    @staticmethod
    def get_item(list: PyObjectLike, index: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyList_GetItem"], _deref_maybe(list), index)

    # PyList_GetSlice
    @staticmethod
    def get_slice(list: PyObjectLike, low: int, high: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyList_GetSlice"], _deref_maybe(list), low, high
        )

    # PyList_Insert
    @staticmethod
    def insert(list: PyObjectLike, index: int, item: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyList_Insert"], _deref_maybe(list), index, _deref_maybe(item)
        )

    # PyList_New
    @staticmethod
    def new(len: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyList_New"], len)

    # PyList_Reverse
    @staticmethod
    def reverse(list: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyList_Reverse"], _deref_maybe(list))

    # PyList_SetItem
    @staticmethod
    def set_item(list: PyObjectLike, index: int, item: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyList_SetItem"], _deref_maybe(list), index, _deref_maybe(item)
        )

    # PyList_SetSlice
    @staticmethod
    def set_slice(
        list: PyObjectLike, low: int, high: int, itemlist: PyObjectLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyList_SetSlice"],
            _deref_maybe(list),
            low,
            high,
            _deref_maybe(itemlist),
        )

    # PyList_Size
    @staticmethod
    def size(list: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyList_Size"], _deref_maybe(list))

    # PyList_Sort
    @staticmethod
    def sort(list: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyList_Sort"], _deref_maybe(list))


class PyLong(_CallBase):
    """Namespace containing API functions prefixed with `PyLong_`"""

    # PyLong_AsDouble
    @staticmethod
    def as_double(pylong: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyLong_AsDouble"], _deref_maybe(pylong))

    # PyLong_AsLong
    @staticmethod
    def as_long(obj: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyLong_AsLong"], _deref_maybe(obj))

    # PyLong_AsLongAndOverflow
    @staticmethod
    def as_long_and_overflow(obj: PyObjectLike, overflow: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyLong_AsLongAndOverflow"], _deref_maybe(obj), overflow
        )

    # PyLong_AsLongLong
    @staticmethod
    def as_long_long(obj: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyLong_AsLongLong"], _deref_maybe(obj))

    # PyLong_AsLongLongAndOverflow
    @staticmethod
    def as_long_long_and_overflow(obj: PyObjectLike, overflow: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyLong_AsLongLongAndOverflow"], _deref_maybe(obj), overflow
        )

    # PyLong_AsSize_t
    @staticmethod
    def as_size_t(pylong: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyLong_AsSize_t"], _deref_maybe(pylong))

    # PyLong_AsSsize_t
    @staticmethod
    def as_ssize_t(pylong: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyLong_AsSsize_t"], _deref_maybe(pylong))

    # PyLong_AsUnsignedLong
    @staticmethod
    def as_unsigned_long(pylong: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyLong_AsUnsignedLong"], _deref_maybe(pylong)
        )

    # PyLong_AsUnsignedLongLong
    @staticmethod
    def as_unsigned_long_long(pylong: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyLong_AsUnsignedLongLong"], _deref_maybe(pylong)
        )

    # PyLong_AsUnsignedLongLongMask
    @staticmethod
    def as_unsigned_long_long_mask(obj: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyLong_AsUnsignedLongLongMask"], _deref_maybe(obj)
        )

    # PyLong_AsUnsignedLongMask
    @staticmethod
    def as_unsigned_long_mask(obj: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyLong_AsUnsignedLongMask"], _deref_maybe(obj)
        )

    # PyLong_AsVoidPtr
    @staticmethod
    def as_void_ptr(pylong: PyObjectLike) -> PointerLike:
        return api_binding_base(API_FUNCS["PyLong_AsVoidPtr"], _deref_maybe(pylong))

    # PyLong_FromDouble
    @staticmethod
    def from_double(v: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyLong_FromDouble"], v)

    # PyLong_FromLong
    @staticmethod
    def from_long(v: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyLong_FromLong"], v)

    # PyLong_FromLongLong
    @staticmethod
    def from_long_long(v: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyLong_FromLongLong"], v)

    # PyLong_FromSize_t
    @staticmethod
    def from_size_t(v: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyLong_FromSize_t"], v)

    # PyLong_FromSsize_t
    @staticmethod
    def from_ssize_t(v: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyLong_FromSsize_t"], v)

    # PyLong_FromString
    @staticmethod
    def from_string(str: StringLike, pend: PointerLike, base: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyLong_FromString"], make_string(str), pend, base
        )

    # PyLong_FromUnsignedLong
    @staticmethod
    def from_unsigned_long(v: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyLong_FromUnsignedLong"], v)

    # PyLong_FromUnsignedLongLong
    @staticmethod
    def from_unsigned_long_long(v: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyLong_FromUnsignedLongLong"], v)

    # PyLong_FromVoidPtr
    @staticmethod
    def from_void_ptr(p: PointerLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyLong_FromVoidPtr"], p)


class PyMapping(_CallBase):
    """Namespace containing API functions prefixed with `PyMapping_`"""

    # PyMapping_Check
    @staticmethod
    def check(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyMapping_Check"], _deref_maybe(o))

    # PyMapping_GetItemString
    @staticmethod
    def get_item_string(o: PyObjectLike, key: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyMapping_GetItemString"], _deref_maybe(o), make_string(key)
        )

    # PyMapping_HasKey
    @staticmethod
    def has_key(o: PyObjectLike, key: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyMapping_HasKey"], _deref_maybe(o), _deref_maybe(key)
        )

    # PyMapping_HasKeyString
    @staticmethod
    def has_key_string(o: PyObjectLike, key: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyMapping_HasKeyString"], _deref_maybe(o), make_string(key)
        )

    # PyMapping_Items
    @staticmethod
    def items(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyMapping_Items"], _deref_maybe(o))

    # PyMapping_Keys
    @staticmethod
    def keys(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyMapping_Keys"], _deref_maybe(o))

    # PyMapping_Length
    @staticmethod
    def length(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyMapping_Length"], _deref_maybe(o))

    # PyMapping_SetItemString
    @staticmethod
    def set_item_string(o: PyObjectLike, key: StringLike, v: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyMapping_SetItemString"],
            _deref_maybe(o),
            make_string(key),
            _deref_maybe(v),
        )

    # PyMapping_Size
    @staticmethod
    def size(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyMapping_Size"], _deref_maybe(o))

    # PyMapping_Values
    @staticmethod
    def values(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyMapping_Values"], _deref_maybe(o))


class PyMem(_CallBase):
    """Namespace containing API functions prefixed with `PyMem_`"""

    # PyMem_Calloc
    @staticmethod
    def calloc(nelem: int, elsize: int) -> PointerLike:
        return api_binding_base(API_FUNCS["PyMem_Calloc"], nelem, elsize)

    # PyMem_Free
    @staticmethod
    def free(p: PointerLike) -> None:
        return api_binding_base(API_FUNCS["PyMem_Free"], p)

    # PyMem_Malloc
    @staticmethod
    def malloc(n: int) -> PointerLike:
        return api_binding_base(API_FUNCS["PyMem_Malloc"], n)

    # PyMem_Realloc
    @staticmethod
    def realloc(p: PointerLike, n: int) -> PointerLike:
        return api_binding_base(API_FUNCS["PyMem_Realloc"], p, n)


class PyMemoryView(_CallBase):
    """Namespace containing API functions prefixed with `PyMemoryView_`"""

    # PyMemoryView_FromBuffer
    @staticmethod
    def from_buffer(view: StructPointer[Buffer]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyMemoryView_FromBuffer"], view)

    # PyMemoryView_FromMemory
    @staticmethod
    def from_memory(mem: StringLike, size: int, flags: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyMemoryView_FromMemory"], make_string(mem), size, flags
        )

    # PyMemoryView_FromObject
    @staticmethod
    def from_object(obj: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyMemoryView_FromObject"], _deref_maybe(obj))

    # PyMemoryView_GetContiguous
    @staticmethod
    def get_contiguous(
        obj: PyObjectLike, buffertype: int, order: CharLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyMemoryView_GetContiguous"],
            _deref_maybe(obj),
            buffertype,
            make_char(order),
        )


class PyModuleDef(_CallBase):
    """Namespace containing API functions prefixed with `PyModuleDef_`"""

    # PyModuleDef_Init
    @staticmethod
    def init(df: StructPointer[ModuleDef]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyModuleDef_Init"], df)


class PyModule(_CallBase):
    """Namespace containing API functions prefixed with `PyModule_`"""

    # PyModule_AddFunctions
    @staticmethod
    def add_functions(module: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyModule_AddFunctions"], _deref_maybe(module)
        )

    # PyModule_AddIntConstant
    @staticmethod
    def add_int_constant(module: PyObjectLike, name: StringLike, value: int) -> int:
        return api_binding_base(
            API_FUNCS["PyModule_AddIntConstant"],
            _deref_maybe(module),
            make_string(name),
            value,
        )

    # PyModule_AddObject
    @staticmethod
    def add_object(module: PyObjectLike, name: StringLike, value: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyModule_AddObject"],
            _deref_maybe(module),
            make_string(name),
            _deref_maybe(value),
        )

    # PyModule_AddObjectRef
    @staticmethod
    def add_object_ref(
        module: PyObjectLike, name: StringLike, value: PyObjectLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyModule_AddObjectRef"],
            _deref_maybe(module),
            make_string(name),
            _deref_maybe(value),
        )

    # PyModule_AddStringConstant
    @staticmethod
    def add_string_constant(
        module: PyObjectLike, name: StringLike, value: StringLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyModule_AddStringConstant"],
            _deref_maybe(module),
            make_string(name),
            make_string(value),
        )

    # PyModule_AddType
    @staticmethod
    def add_type(module: PyObjectLike, type: StructPointer[TypeObject]) -> int:
        return api_binding_base(
            API_FUNCS["PyModule_AddType"], _deref_maybe(module), type
        )

    # PyModule_Create2
    @staticmethod
    def create2(df: StructPointer[ModuleDef], module_api_version: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyModule_Create2"], df, module_api_version)

    # PyModule_ExecDef
    @staticmethod
    def exec_def(module: PyObjectLike, df: StructPointer[ModuleDef]) -> int:
        return api_binding_base(API_FUNCS["PyModule_ExecDef"], _deref_maybe(module), df)

    # PyModule_FromDefAndSpec2
    @staticmethod
    def from_def_and_spec2(
        df: StructPointer[ModuleDef], spec: PyObjectLike, module_api_version: int
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyModule_FromDefAndSpec2"],
            df,
            _deref_maybe(spec),
            module_api_version,
        )

    # PyModule_GetDef
    @staticmethod
    def get_def(module: PyObjectLike) -> StructPointer[ModuleDef]:
        return api_binding_base(API_FUNCS["PyModule_GetDef"], _deref_maybe(module))

    # PyModule_GetDict
    @staticmethod
    def get_dict(module: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyModule_GetDict"], _deref_maybe(module))

    # PyModule_GetFilename
    @staticmethod
    def get_filename(module: PyObjectLike) -> StringLike:
        return api_binding_base(API_FUNCS["PyModule_GetFilename"], _deref_maybe(module))

    # PyModule_GetFilenameObject
    @staticmethod
    def get_filename_object(module: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyModule_GetFilenameObject"], _deref_maybe(module)
        )

    # PyModule_GetName
    @staticmethod
    def get_name(module: PyObjectLike) -> StringLike:
        return api_binding_base(API_FUNCS["PyModule_GetName"], _deref_maybe(module))

    # PyModule_GetNameObject
    @staticmethod
    def get_name_object(module: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyModule_GetNameObject"], _deref_maybe(module)
        )

    # PyModule_GetState
    @staticmethod
    def get_state(module: PyObjectLike) -> PointerLike:
        return api_binding_base(API_FUNCS["PyModule_GetState"], _deref_maybe(module))

    # PyModule_New
    @staticmethod
    def new(name: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyModule_New"], make_string(name))

    # PyModule_NewObject
    @staticmethod
    def new_object(name: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyModule_NewObject"], _deref_maybe(name))

    # PyModule_SetDocString
    @staticmethod
    def set_doc_string(module: PyObjectLike, docstring: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyModule_SetDocString"],
            _deref_maybe(module),
            make_string(docstring),
        )


class PyNumber(_CallBase):
    """Namespace containing API functions prefixed with `PyNumber_`"""

    # PyNumber_Absolute
    @staticmethod
    def absolute(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyNumber_Absolute"], _deref_maybe(o))

    # PyNumber_Add
    @staticmethod
    def add(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Add"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_And
    @staticmethod
    def and_(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_And"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_AsSsize_t
    @staticmethod
    def as_ssize_t(o: PyObjectLike, exc: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyNumber_AsSsize_t"], _deref_maybe(o), _deref_maybe(exc)
        )

    # PyNumber_Check
    @staticmethod
    def check(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyNumber_Check"], _deref_maybe(o))

    # PyNumber_Divmod
    @staticmethod
    def divmod(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Divmod"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_Float
    @staticmethod
    def float(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyNumber_Float"], _deref_maybe(o))

    # PyNumber_FloorDivide
    @staticmethod
    def floor_divide(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_FloorDivide"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceAdd
    @staticmethod
    def in_place_add(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceAdd"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceAnd
    @staticmethod
    def in_place_and(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceAnd"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceFloorDivide
    @staticmethod
    def in_place_floor_divide(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceFloorDivide"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceLshift
    @staticmethod
    def in_place_lshift(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceLshift"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceMatrixMultiply
    @staticmethod
    def in_place_matrix_multiply(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceMatrixMultiply"],
            _deref_maybe(o1),
            _deref_maybe(o2),
        )

    # PyNumber_InPlaceMultiply
    @staticmethod
    def in_place_multiply(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceMultiply"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceOr
    @staticmethod
    def in_place_or(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceOr"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlacePower
    @staticmethod
    def in_place_power(
        o1: PyObjectLike, o2: PyObjectLike, o3: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlacePower"],
            _deref_maybe(o1),
            _deref_maybe(o2),
            _deref_maybe(o3),
        )

    # PyNumber_InPlaceRemainder
    @staticmethod
    def in_place_remainder(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceRemainder"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceRshift
    @staticmethod
    def in_place_rshift(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceRshift"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceSubtract
    @staticmethod
    def in_place_subtract(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceSubtract"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceTrueDivide
    @staticmethod
    def in_place_true_divide(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceTrueDivide"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_InPlaceXor
    @staticmethod
    def in_place_xor(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_InPlaceXor"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_Index
    @staticmethod
    def index(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyNumber_Index"], _deref_maybe(o))

    # PyNumber_Invert
    @staticmethod
    def invert(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyNumber_Invert"], _deref_maybe(o))

    # PyNumber_Long
    @staticmethod
    def long(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyNumber_Long"], _deref_maybe(o))

    # PyNumber_Lshift
    @staticmethod
    def lshift(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Lshift"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_MatrixMultiply
    @staticmethod
    def matrix_multiply(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_MatrixMultiply"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_Multiply
    @staticmethod
    def multiply(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Multiply"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_Negative
    @staticmethod
    def negative(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyNumber_Negative"], _deref_maybe(o))

    # PyNumber_Or
    @staticmethod
    def or_(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Or"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_Positive
    @staticmethod
    def positive(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyNumber_Positive"], _deref_maybe(o))

    # PyNumber_Power
    @staticmethod
    def power(o1: PyObjectLike, o2: PyObjectLike, o3: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Power"],
            _deref_maybe(o1),
            _deref_maybe(o2),
            _deref_maybe(o3),
        )

    # PyNumber_Remainder
    @staticmethod
    def remainder(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Remainder"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_Rshift
    @staticmethod
    def rshift(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Rshift"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_Subtract
    @staticmethod
    def subtract(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Subtract"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_ToBase
    @staticmethod
    def to_base(n: PyObjectLike, base: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyNumber_ToBase"], _deref_maybe(n), base)

    # PyNumber_TrueDivide
    @staticmethod
    def true_divide(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_TrueDivide"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PyNumber_Xor
    @staticmethod
    def xor(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyNumber_Xor"], _deref_maybe(o1), _deref_maybe(o2)
        )


class PyOS(_CallBase):
    """Namespace containing API functions prefixed with `PyOS_`"""

    # PyOS_AfterFork
    @staticmethod
    def after_fork() -> None:
        return api_binding_base(
            API_FUNCS["PyOS_AfterFork"],
        )

    # PyOS_AfterFork_Child
    @staticmethod
    def after_fork__child() -> None:
        return api_binding_base(
            API_FUNCS["PyOS_AfterFork_Child"],
        )

    # PyOS_AfterFork_Parent
    @staticmethod
    def after_fork__parent() -> None:
        return api_binding_base(
            API_FUNCS["PyOS_AfterFork_Parent"],
        )

    # PyOS_BeforeFork
    @staticmethod
    def before_fork() -> None:
        return api_binding_base(
            API_FUNCS["PyOS_BeforeFork"],
        )

    # PyOS_FSPath
    @staticmethod
    def fs__path(path: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyOS_FSPath"], _deref_maybe(path))

    # PyOS_double_to_string
    @staticmethod
    def double_to_string(
        val: int, format_code: CharLike, precision: int, flags: int, ptype: PointerLike
    ) -> StringLike:
        return api_binding_base(
            API_FUNCS["PyOS_double_to_string"],
            val,
            make_char(format_code),
            precision,
            flags,
            ptype,
        )

    # PyOS_getsig
    @staticmethod
    def getsig(i: int) -> PointerLike:
        return api_binding_base(API_FUNCS["PyOS_getsig"], i)

    # PyOS_setsig
    @staticmethod
    def setsig(i: int, h: PointerLike) -> PointerLike:
        return api_binding_base(API_FUNCS["PyOS_setsig"], i, h)

    # PyOS_string_to_double
    @staticmethod
    def string_to_double(
        s: StringLike, endptr: PointerLike, overflow_exception: PyObjectLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyOS_string_to_double"],
            make_string(s),
            endptr,
            _deref_maybe(overflow_exception),
        )

    # PyOS_vsnprintf
    @staticmethod
    def vsnprintf(
        str: StringLike, size: int, format: StringLike, va: PointerLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyOS_vsnprintf"], make_string(str), size, make_string(format), va
        )


class PyObject(_CallBase):
    """Namespace containing API functions prefixed with `PyObject_`"""

    # PyObject_ASCII
    @staticmethod
    def ascii(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyObject_ASCII"], _deref_maybe(o))

    # PyObject_AsCharBuffer
    @staticmethod
    def as_char_buffer(
        obj: PyObjectLike, buffer: PointerLike, buffer_len: PointerLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_AsCharBuffer"], _deref_maybe(obj), buffer, buffer_len
        )

    # PyObject_AsFileDescriptor
    @staticmethod
    def as_file_descriptor(p: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_AsFileDescriptor"], _deref_maybe(p))

    # PyObject_AsReadBuffer
    @staticmethod
    def as_read_buffer(
        obj: PyObjectLike, buffer: PointerLike, buffer_len: PointerLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_AsReadBuffer"], _deref_maybe(obj), buffer, buffer_len
        )

    # PyObject_AsWriteBuffer
    @staticmethod
    def as_write_buffer(
        obj: PyObjectLike, buffer: PointerLike, buffer_len: PointerLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_AsWriteBuffer"], _deref_maybe(obj), buffer, buffer_len
        )

    # PyObject_Bytes
    @staticmethod
    def bytes(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyObject_Bytes"], _deref_maybe(o))

    # PyObject_Call
    @staticmethod
    def call(
        callable: PyObjectLike, args: PyObjectLike, kwargs: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyObject_Call"],
            _deref_maybe(callable),
            _deref_maybe(args),
            _deref_maybe(kwargs),
        )

    # PyObject_CallNoArgs
    @staticmethod
    def call_no_args(callable: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyObject_CallNoArgs"], _deref_maybe(callable)
        )

    # PyObject_CallObject
    @staticmethod
    def call_object(callable: PyObjectLike, args: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyObject_CallObject"], _deref_maybe(callable), _deref_maybe(args)
        )

    # PyObject_Calloc
    @staticmethod
    def calloc(nelem: int, elsize: int) -> PointerLike:
        return api_binding_base(API_FUNCS["PyObject_Calloc"], nelem, elsize)

    # PyObject_CheckBuffer
    @staticmethod
    def check_buffer(obj: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_CheckBuffer"], _deref_maybe(obj))

    # PyObject_CheckReadBuffer
    @staticmethod
    def check_read_buffer(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_CheckReadBuffer"], _deref_maybe(o))

    # PyObject_CopyData
    @staticmethod
    def copy_data(dest: StructPointer[Buffer], src: StructPointer[Buffer]) -> int:
        return api_binding_base(API_FUNCS["PyObject_CopyData"], dest, src)

    # PyObject_DelItem
    @staticmethod
    def del_item(o: PyObjectLike, key: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_DelItem"], _deref_maybe(o), _deref_maybe(key)
        )

    # PyObject_Dir
    @staticmethod
    def dir(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyObject_Dir"], _deref_maybe(o))

    # PyObject_Free
    @staticmethod
    def free(p: PointerLike) -> None:
        return api_binding_base(API_FUNCS["PyObject_Free"], p)

    # PyObject_GC_Del
    @staticmethod
    def gc_del(op: PointerLike) -> None:
        return api_binding_base(API_FUNCS["PyObject_GC_Del"], op)

    # PyObject_GC_IsFinalized
    @staticmethod
    def gc_is_finalized(op: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_GC_IsFinalized"], _deref_maybe(op))

    # PyObject_GC_IsTracked
    @staticmethod
    def gc_is_tracked(op: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_GC_IsTracked"], _deref_maybe(op))

    # PyObject_GC_Track
    @staticmethod
    def gc_track(op: PyObjectLike) -> None:
        return api_binding_base(API_FUNCS["PyObject_GC_Track"], _deref_maybe(op))

    # PyObject_GC_UnTrack
    @staticmethod
    def gc_untrack(op: PointerLike) -> None:
        return api_binding_base(API_FUNCS["PyObject_GC_UnTrack"], op)

    # PyObject_GenericGetAttr
    @staticmethod
    def generic_get_attr(o: PyObjectLike, name: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyObject_GenericGetAttr"], _deref_maybe(o), _deref_maybe(name)
        )

    # PyObject_GenericGetDict
    @staticmethod
    def generic_get_dict(o: PyObjectLike, context: PointerLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyObject_GenericGetDict"], _deref_maybe(o), context
        )

    # PyObject_GenericSetAttr
    @staticmethod
    def generic_set_attr(
        o: PyObjectLike, name: PyObjectLike, value: PyObjectLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_GenericSetAttr"],
            _deref_maybe(o),
            _deref_maybe(name),
            _deref_maybe(value),
        )

    # PyObject_GenericSetDict
    @staticmethod
    def generic_set_dict(
        o: PyObjectLike, value: PyObjectLike, context: PointerLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_GenericSetDict"],
            _deref_maybe(o),
            _deref_maybe(value),
            context,
        )

    # PyObject_GetAIter
    @staticmethod
    def get_a_iter(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyObject_GetAIter"], _deref_maybe(o))

    # PyObject_GetAttr
    @staticmethod
    def get_attr(o: PyObjectLike, attr_name: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyObject_GetAttr"], _deref_maybe(o), _deref_maybe(attr_name)
        )

    # PyObject_GetAttrString
    @staticmethod
    def get_attr_string(o: PyObjectLike, attr_name: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyObject_GetAttrString"], _deref_maybe(o), make_string(attr_name)
        )

    # PyObject_GetBuffer
    @staticmethod
    def get_buffer(
        exporter: PyObjectLike, view: StructPointer[Buffer], flags: int
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_GetBuffer"], _deref_maybe(exporter), view, flags
        )

    # PyObject_GetItem
    @staticmethod
    def get_item(o: PyObjectLike, key: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyObject_GetItem"], _deref_maybe(o), _deref_maybe(key)
        )

    # PyObject_GetIter
    @staticmethod
    def get_iter(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyObject_GetIter"], _deref_maybe(o))

    # PyObject_HasAttr
    @staticmethod
    def has_attr(o: PyObjectLike, attr_name: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_HasAttr"], _deref_maybe(o), _deref_maybe(attr_name)
        )

    # PyObject_HasAttrString
    @staticmethod
    def has_attr_string(o: PyObjectLike, attr_name: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_HasAttrString"], _deref_maybe(o), make_string(attr_name)
        )

    # PyObject_Hash
    @staticmethod
    def hash(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_Hash"], _deref_maybe(o))

    # PyObject_HashNotImplemented
    @staticmethod
    def hash_not_implemented(o: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_HashNotImplemented"], _deref_maybe(o)
        )

    # PyObject_Init
    @staticmethod
    def init(op: PyObjectLike, type: StructPointer[TypeObject]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyObject_Init"], _deref_maybe(op), type)

    # PyObject_InitVar
    @staticmethod
    def init_var(
        op: StructPointer[VarObject], type: StructPointer[TypeObject], size: int
    ) -> StructPointer[VarObject]:
        return api_binding_base(API_FUNCS["PyObject_InitVar"], op, type, size)

    # PyObject_IsInstance
    @staticmethod
    def is_instance(inst: PyObjectLike, cls: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_IsInstance"], _deref_maybe(inst), _deref_maybe(cls)
        )

    # PyObject_IsSubclass
    @staticmethod
    def is_subclass(derived: PyObjectLike, cls: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_IsSubclass"], _deref_maybe(derived), _deref_maybe(cls)
        )

    # PyObject_IsTrue
    @staticmethod
    def is_true(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_IsTrue"], _deref_maybe(o))

    # PyObject_Length
    @staticmethod
    def length(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_Length"], _deref_maybe(o))

    # PyObject_Malloc
    @staticmethod
    def malloc(n: int) -> PointerLike:
        return api_binding_base(API_FUNCS["PyObject_Malloc"], n)

    # PyObject_Not
    @staticmethod
    def not_(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_Not"], _deref_maybe(o))

    # PyObject_Realloc
    @staticmethod
    def realloc(p: PointerLike, n: int) -> PointerLike:
        return api_binding_base(API_FUNCS["PyObject_Realloc"], p, n)

    # PyObject_Repr
    @staticmethod
    def repr(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyObject_Repr"], _deref_maybe(o))

    # PyObject_RichCompare
    @staticmethod
    def rich_compare(o1: PyObjectLike, o2: PyObjectLike, opid: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyObject_RichCompare"], _deref_maybe(o1), _deref_maybe(o2), opid
        )

    # PyObject_RichCompareBool
    @staticmethod
    def rich_compare_bool(o1: PyObjectLike, o2: PyObjectLike, opid: int) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_RichCompareBool"],
            _deref_maybe(o1),
            _deref_maybe(o2),
            opid,
        )

    # PyObject_SetAttr
    @staticmethod
    def set_attr(o: PyObjectLike, attr_name: PyObjectLike, v: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_SetAttr"],
            _deref_maybe(o),
            _deref_maybe(attr_name),
            _deref_maybe(v),
        )

    # PyObject_SetAttrString
    @staticmethod
    def set_attr_string(o: PyObjectLike, attr_name: StringLike, v: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_SetAttrString"],
            _deref_maybe(o),
            make_string(attr_name),
            _deref_maybe(v),
        )

    # PyObject_SetItem
    @staticmethod
    def set_item(o: PyObjectLike, key: PyObjectLike, v: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyObject_SetItem"],
            _deref_maybe(o),
            _deref_maybe(key),
            _deref_maybe(v),
        )

    # PyObject_Size
    @staticmethod
    def size(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyObject_Size"], _deref_maybe(o))

    # PyObject_Str
    @staticmethod
    def str(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyObject_Str"], _deref_maybe(o))

    # PyObject_Type
    @staticmethod
    def type(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyObject_Type"], _deref_maybe(o))


class PySeqIter(_CallBase):
    """Namespace containing API functions prefixed with `PySeqIter_`"""

    # PySeqIter_New
    @staticmethod
    def new(seq: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PySeqIter_New"], _deref_maybe(seq))


class PySequence(_CallBase):
    """Namespace containing API functions prefixed with `PySequence_`"""

    # PySequence_Check
    @staticmethod
    def check(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PySequence_Check"], _deref_maybe(o))

    # PySequence_Concat
    @staticmethod
    def concat(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PySequence_Concat"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PySequence_Contains
    @staticmethod
    def contains(o: PyObjectLike, value: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PySequence_Contains"], _deref_maybe(o), _deref_maybe(value)
        )

    # PySequence_Count
    @staticmethod
    def count(o: PyObjectLike, value: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PySequence_Count"], _deref_maybe(o), _deref_maybe(value)
        )

    # PySequence_DelItem
    @staticmethod
    def del_item(o: PyObjectLike, i: int) -> int:
        return api_binding_base(API_FUNCS["PySequence_DelItem"], _deref_maybe(o), i)

    # PySequence_DelSlice
    @staticmethod
    def del_slice(o: PyObjectLike, i1: int, i2: int) -> int:
        return api_binding_base(
            API_FUNCS["PySequence_DelSlice"], _deref_maybe(o), i1, i2
        )

    # PySequence_Fast
    @staticmethod
    def fast(o: PyObjectLike, m: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PySequence_Fast"], _deref_maybe(o), make_string(m)
        )

    # PySequence_GetItem
    @staticmethod
    def get_item(o: PyObjectLike, i: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PySequence_GetItem"], _deref_maybe(o), i)

    # PySequence_GetSlice
    @staticmethod
    def get_slice(o: PyObjectLike, i1: int, i2: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PySequence_GetSlice"], _deref_maybe(o), i1, i2
        )

    # PySequence_InPlaceConcat
    @staticmethod
    def in_place_concat(o1: PyObjectLike, o2: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PySequence_InPlaceConcat"], _deref_maybe(o1), _deref_maybe(o2)
        )

    # PySequence_InPlaceRepeat
    @staticmethod
    def in_place_repeat(o: PyObjectLike, count: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PySequence_InPlaceRepeat"], _deref_maybe(o), count
        )

    # PySequence_Index
    @staticmethod
    def index(o: PyObjectLike, value: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PySequence_Index"], _deref_maybe(o), _deref_maybe(value)
        )

    # PySequence_Length
    @staticmethod
    def length(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PySequence_Length"], _deref_maybe(o))

    # PySequence_List
    @staticmethod
    def list(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PySequence_List"], _deref_maybe(o))

    # PySequence_Repeat
    @staticmethod
    def repeat(o: PyObjectLike, count: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PySequence_Repeat"], _deref_maybe(o), count)

    # PySequence_SetItem
    @staticmethod
    def set_item(o: PyObjectLike, i: int, v: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PySequence_SetItem"], _deref_maybe(o), i, _deref_maybe(v)
        )

    # PySequence_SetSlice
    @staticmethod
    def set_slice(o: PyObjectLike, i1: int, i2: int, v: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PySequence_SetSlice"], _deref_maybe(o), i1, i2, _deref_maybe(v)
        )

    # PySequence_Size
    @staticmethod
    def size(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PySequence_Size"], _deref_maybe(o))

    # PySequence_Tuple
    @staticmethod
    def tuple(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PySequence_Tuple"], _deref_maybe(o))


class PySet(_CallBase):
    """Namespace containing API functions prefixed with `PySet_`"""

    # PySet_Add
    @staticmethod
    def add(set: PyObjectLike, key: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PySet_Add"], _deref_maybe(set), _deref_maybe(key)
        )

    # PySet_Clear
    @staticmethod
    def clear(set: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PySet_Clear"], _deref_maybe(set))

    # PySet_Contains
    @staticmethod
    def contains(anyset: PyObjectLike, key: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PySet_Contains"], _deref_maybe(anyset), _deref_maybe(key)
        )

    # PySet_Discard
    @staticmethod
    def discard(set: PyObjectLike, key: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PySet_Discard"], _deref_maybe(set), _deref_maybe(key)
        )

    # PySet_New
    @staticmethod
    def new(iterable: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PySet_New"], _deref_maybe(iterable))

    # PySet_Pop
    @staticmethod
    def pop(set: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PySet_Pop"], _deref_maybe(set))

    # PySet_Size
    @staticmethod
    def size(anyset: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PySet_Size"], _deref_maybe(anyset))


class PySlice(_CallBase):
    """Namespace containing API functions prefixed with `PySlice_`"""

    # PySlice_AdjustIndices
    @staticmethod
    def adjust_indices(
        length: int, start: PointerLike, stop: PointerLike, step: int
    ) -> int:
        return api_binding_base(
            API_FUNCS["PySlice_AdjustIndices"], length, start, stop, step
        )

    # PySlice_GetIndices
    @staticmethod
    def get_indices(
        slice: PyObjectLike,
        length: int,
        start: PointerLike,
        stop: PointerLike,
        step: PointerLike,
    ) -> int:
        return api_binding_base(
            API_FUNCS["PySlice_GetIndices"],
            _deref_maybe(slice),
            length,
            start,
            stop,
            step,
        )

    # PySlice_GetIndicesEx
    @staticmethod
    def get_indices_ex(
        slice: PyObjectLike,
        length: int,
        start: PointerLike,
        stop: PointerLike,
        step: PointerLike,
        slicelength: PointerLike,
    ) -> int:
        return api_binding_base(
            API_FUNCS["PySlice_GetIndicesEx"],
            _deref_maybe(slice),
            length,
            start,
            stop,
            step,
            slicelength,
        )

    # PySlice_New
    @staticmethod
    def new(
        start: PyObjectLike, stop: PyObjectLike, step: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PySlice_New"],
            _deref_maybe(start),
            _deref_maybe(stop),
            _deref_maybe(step),
        )

    # PySlice_Unpack
    @staticmethod
    def unpack(
        slice: PyObjectLike, start: PointerLike, stop: PointerLike, step: PointerLike
    ) -> int:
        return api_binding_base(
            API_FUNCS["PySlice_Unpack"], _deref_maybe(slice), start, stop, step
        )


class PyState(_CallBase):
    """Namespace containing API functions prefixed with `PyState_`"""

    # PyState_AddModule
    @staticmethod
    def add_module(module: PyObjectLike, df: StructPointer[ModuleDef]) -> int:
        return api_binding_base(
            API_FUNCS["PyState_AddModule"], _deref_maybe(module), df
        )

    # PyState_FindModule
    @staticmethod
    def find_module(df: StructPointer[ModuleDef]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyState_FindModule"], df)

    # PyState_RemoveModule
    @staticmethod
    def remove_module(df: StructPointer[ModuleDef]) -> int:
        return api_binding_base(API_FUNCS["PyState_RemoveModule"], df)


class PyStructSequence(_CallBase):
    """Namespace containing API functions prefixed with `PyStructSequence_`"""

    # PyStructSequence_GetItem
    @staticmethod
    def get_item(p: PyObjectLike, pos: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyStructSequence_GetItem"], _deref_maybe(p), pos
        )

    # PyStructSequence_New
    @staticmethod
    def new(type: StructPointer[TypeObject]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyStructSequence_New"], type)

    # PyStructSequence_NewType
    @staticmethod
    def new_type() -> StructPointer[TypeObject]:
        return api_binding_base(
            API_FUNCS["PyStructSequence_NewType"],
        )

    # PyStructSequence_SetItem
    @staticmethod
    def set_item(p: PyObjectLike, pos: int, o: PyObjectLike) -> None:
        return api_binding_base(
            API_FUNCS["PyStructSequence_SetItem"], _deref_maybe(p), pos, _deref_maybe(o)
        )


class PySys(_CallBase):
    """Namespace containing API functions prefixed with `PySys_`"""

    # PySys_AddWarnOption
    @staticmethod
    def add_warn_option(s: str) -> None:
        return api_binding_base(API_FUNCS["PySys_AddWarnOption"], s)

    # PySys_AddWarnOptionUnicode
    @staticmethod
    def add_warn_option_unicode(unicode: PyObjectLike) -> None:
        return api_binding_base(
            API_FUNCS["PySys_AddWarnOptionUnicode"], _deref_maybe(unicode)
        )

    # PySys_AddXOption
    @staticmethod
    def add_x_option(s: str) -> None:
        return api_binding_base(API_FUNCS["PySys_AddXOption"], s)

    # PySys_GetObject
    @staticmethod
    def get_object(name: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PySys_GetObject"], make_string(name))

    # PySys_GetXOptions
    @staticmethod
    def get_x_options() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PySys_GetXOptions"],
        )

    # PySys_ResetWarnOptions
    @staticmethod
    def reset_warn_options() -> None:
        return api_binding_base(
            API_FUNCS["PySys_ResetWarnOptions"],
        )

    # PySys_SetArgv
    @staticmethod
    def set_argv(argc: int, argv: PointerLike) -> None:
        return api_binding_base(API_FUNCS["PySys_SetArgv"], argc, argv)

    # PySys_SetArgvEx
    @staticmethod
    def set_argv_ex(argc: int, argv: PointerLike, updatepath: int) -> None:
        return api_binding_base(API_FUNCS["PySys_SetArgvEx"], argc, argv, updatepath)

    # PySys_SetObject
    @staticmethod
    def set_object(name: StringLike, v: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PySys_SetObject"], make_string(name), _deref_maybe(v)
        )

    # PySys_SetPath
    @staticmethod
    def set_path(path: str) -> None:
        return api_binding_base(API_FUNCS["PySys_SetPath"], path)


class PyThreadState(_CallBase):
    """Namespace containing API functions prefixed with `PyThreadState_`"""

    # PyThreadState_Clear
    @staticmethod
    def clear(tstate: StructPointer[ThreadState]) -> None:
        return api_binding_base(API_FUNCS["PyThreadState_Clear"], tstate)

    # PyThreadState_Delete
    @staticmethod
    def delete(tstate: StructPointer[ThreadState]) -> None:
        return api_binding_base(API_FUNCS["PyThreadState_Delete"], tstate)

    # PyThreadState_Get
    @staticmethod
    def get() -> StructPointer[ThreadState]:
        return api_binding_base(
            API_FUNCS["PyThreadState_Get"],
        )

    # PyThreadState_GetDict
    @staticmethod
    def get_dict() -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyThreadState_GetDict"],
        )

    # PyThreadState_GetFrame
    @staticmethod
    def get_frame(tstate: StructPointer[ThreadState]) -> StructPointer[FrameObject]:
        return api_binding_base(API_FUNCS["PyThreadState_GetFrame"], tstate)

    # PyThreadState_GetID
    @staticmethod
    def get_i_d(tstate: StructPointer[ThreadState]) -> int:
        return api_binding_base(API_FUNCS["PyThreadState_GetID"], tstate)

    # PyThreadState_GetInterpreter
    @staticmethod
    def get_interpreter(
        tstate: StructPointer[ThreadState],
    ) -> StructPointer[InterpreterState]:
        return api_binding_base(API_FUNCS["PyThreadState_GetInterpreter"], tstate)

    # PyThreadState_New
    @staticmethod
    def new(interp: StructPointer[InterpreterState]) -> StructPointer[ThreadState]:
        return api_binding_base(API_FUNCS["PyThreadState_New"], interp)

    # PyThreadState_SetAsyncExc
    @staticmethod
    def set_async_exc(id: int, exc: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyThreadState_SetAsyncExc"], id, _deref_maybe(exc)
        )

    # PyThreadState_Swap
    @staticmethod
    def swap(tstate: StructPointer[ThreadState]) -> StructPointer[ThreadState]:
        return api_binding_base(API_FUNCS["PyThreadState_Swap"], tstate)


class PyThread(_CallBase):
    """Namespace containing API functions prefixed with `PyThread_`"""

    # PyThread_ReInitTLS
    @staticmethod
    def re_init_t_l_s() -> None:
        return api_binding_base(
            API_FUNCS["PyThread_ReInitTLS"],
        )

    # PyThread_create_key
    @staticmethod
    def create_key() -> int:
        return api_binding_base(
            API_FUNCS["PyThread_create_key"],
        )

    # PyThread_delete_key
    @staticmethod
    def delete_key(key: int) -> None:
        return api_binding_base(API_FUNCS["PyThread_delete_key"], key)

    # PyThread_delete_key_value
    @staticmethod
    def delete_key_value(key: int) -> None:
        return api_binding_base(API_FUNCS["PyThread_delete_key_value"], key)

    # PyThread_get_key_value
    @staticmethod
    def get_key_value(key: int) -> PointerLike:
        return api_binding_base(API_FUNCS["PyThread_get_key_value"], key)

    # PyThread_set_key_value
    @staticmethod
    def set_key_value(key: int, value: PointerLike) -> int:
        return api_binding_base(API_FUNCS["PyThread_set_key_value"], key, value)

    # PyThread_tss_alloc
    @staticmethod
    def tss_alloc() -> StructPointer[TssT]:
        return api_binding_base(
            API_FUNCS["PyThread_tss_alloc"],
        )

    # PyThread_tss_create
    @staticmethod
    def tss_create(key: StructPointer[TssT]) -> int:
        return api_binding_base(API_FUNCS["PyThread_tss_create"], key)

    # PyThread_tss_delete
    @staticmethod
    def tss_delete(key: StructPointer[TssT]) -> None:
        return api_binding_base(API_FUNCS["PyThread_tss_delete"], key)

    # PyThread_tss_free
    @staticmethod
    def tss_free(key: StructPointer[TssT]) -> None:
        return api_binding_base(API_FUNCS["PyThread_tss_free"], key)

    # PyThread_tss_get
    @staticmethod
    def tss_get(key: StructPointer[TssT]) -> PointerLike:
        return api_binding_base(API_FUNCS["PyThread_tss_get"], key)

    # PyThread_tss_is_created
    @staticmethod
    def tss_is_created(key: StructPointer[TssT]) -> int:
        return api_binding_base(API_FUNCS["PyThread_tss_is_created"], key)

    # PyThread_tss_set
    @staticmethod
    def tss_set(key: StructPointer[TssT], value: PointerLike) -> int:
        return api_binding_base(API_FUNCS["PyThread_tss_set"], key, value)


class PyTuple(_CallBase):
    """Namespace containing API functions prefixed with `PyTuple_`"""

    # PyTuple_GetItem
    @staticmethod
    def get_item(p: PyObjectLike, pos: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyTuple_GetItem"], _deref_maybe(p), pos)

    # PyTuple_GetSlice
    @staticmethod
    def get_slice(p: PyObjectLike, low: int, high: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyTuple_GetSlice"], _deref_maybe(p), low, high
        )

    # PyTuple_New
    @staticmethod
    def new(len: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyTuple_New"], len)

    # PyTuple_SetItem
    @staticmethod
    def set_item(p: PyObjectLike, pos: int, o: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyTuple_SetItem"], _deref_maybe(p), pos, _deref_maybe(o)
        )

    # PyTuple_Size
    @staticmethod
    def size(p: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyTuple_Size"], _deref_maybe(p))


class PyType(_CallBase):
    """Namespace containing API functions prefixed with `PyType_`"""

    # PyType_ClearCache
    @staticmethod
    def clear_cache() -> int:
        return api_binding_base(
            API_FUNCS["PyType_ClearCache"],
        )

    # PyType_FromModuleAndSpec
    @staticmethod
    def from_module_and_spec(
        module: PyObjectLike, spec: StructPointer[PyTypeSpec], bases: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyType_FromModuleAndSpec"],
            _deref_maybe(module),
            spec,
            _deref_maybe(bases),
        )

    # PyType_FromSpec
    @staticmethod
    def from_spec(spec: StructPointer[PyTypeSpec]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyType_FromSpec"], spec)

    # PyType_FromSpecWithBases
    @staticmethod
    def from_spec_with_bases(
        spec: StructPointer[PyTypeSpec], bases: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyType_FromSpecWithBases"], spec, _deref_maybe(bases)
        )

    # PyType_GenericAlloc
    @staticmethod
    def generic_alloc(type: StructPointer[TypeObject], nitems: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyType_GenericAlloc"], type, nitems)

    # PyType_GenericNew
    @staticmethod
    def generic_new(
        type: StructPointer[TypeObject], args: PyObjectLike, kwds: PyObjectLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyType_GenericNew"], type, _deref_maybe(args), _deref_maybe(kwds)
        )

    # PyType_GetFlags
    @staticmethod
    def get_flags(type: StructPointer[TypeObject]) -> int:
        return api_binding_base(API_FUNCS["PyType_GetFlags"], type)

    # PyType_GetModule
    @staticmethod
    def get_module(type: StructPointer[TypeObject]) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyType_GetModule"], type)

    # PyType_GetModuleState
    @staticmethod
    def get_module_state(type: StructPointer[TypeObject]) -> PointerLike:
        return api_binding_base(API_FUNCS["PyType_GetModuleState"], type)

    # PyType_GetSlot
    @staticmethod
    def get_slot(type: StructPointer[TypeObject], slot: int) -> PointerLike:
        return api_binding_base(API_FUNCS["PyType_GetSlot"], type, slot)

    # PyType_IsSubtype
    @staticmethod
    def is_subtype(a: StructPointer[TypeObject], b: StructPointer[TypeObject]) -> int:
        return api_binding_base(API_FUNCS["PyType_IsSubtype"], a, b)

    # PyType_Modified
    @staticmethod
    def modified(type: StructPointer[TypeObject]) -> None:
        return api_binding_base(API_FUNCS["PyType_Modified"], type)

    # PyType_Ready
    @staticmethod
    def ready(type: StructPointer[TypeObject]) -> int:
        return api_binding_base(API_FUNCS["PyType_Ready"], type)


class PyUnicodeDecodeError(_CallBase):
    """Namespace containing API functions prefixed with `PyUnicodeDecodeError_`"""

    # PyUnicodeDecodeError_Create
    @staticmethod
    def create(
        encoding: StringLike,
        object: StringLike,
        length: int,
        start: int,
        end: int,
        reason: StringLike,
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicodeDecodeError_Create"],
            make_string(encoding),
            make_string(object),
            length,
            start,
            end,
            make_string(reason),
        )

    # PyUnicodeDecodeError_GetEncoding
    @staticmethod
    def get_encoding(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicodeDecodeError_GetEncoding"], _deref_maybe(exc)
        )

    # PyUnicodeDecodeError_GetEnd
    @staticmethod
    def get_end(exc: PyObjectLike, end: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeDecodeError_GetEnd"], _deref_maybe(exc), end
        )

    # PyUnicodeDecodeError_GetObject
    @staticmethod
    def get_object(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicodeDecodeError_GetObject"], _deref_maybe(exc)
        )

    # PyUnicodeDecodeError_GetReason
    @staticmethod
    def get_reason(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicodeDecodeError_GetReason"], _deref_maybe(exc)
        )

    # PyUnicodeDecodeError_GetStart
    @staticmethod
    def get_start(exc: PyObjectLike, start: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeDecodeError_GetStart"], _deref_maybe(exc), start
        )

    # PyUnicodeDecodeError_SetEnd
    @staticmethod
    def set_end(exc: PyObjectLike, end: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeDecodeError_SetEnd"], _deref_maybe(exc), end
        )

    # PyUnicodeDecodeError_SetReason
    @staticmethod
    def set_reason(exc: PyObjectLike, reason: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeDecodeError_SetReason"],
            _deref_maybe(exc),
            make_string(reason),
        )

    # PyUnicodeDecodeError_SetStart
    @staticmethod
    def set_start(exc: PyObjectLike, start: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeDecodeError_SetStart"], _deref_maybe(exc), start
        )


class PyUnicodeEncodeError(_CallBase):
    """Namespace containing API functions prefixed with `PyUnicodeEncodeError_`"""

    # PyUnicodeEncodeError_GetEncoding
    @staticmethod
    def get_encoding(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicodeEncodeError_GetEncoding"], _deref_maybe(exc)
        )

    # PyUnicodeEncodeError_GetEnd
    @staticmethod
    def get_end(exc: PyObjectLike, end: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeEncodeError_GetEnd"], _deref_maybe(exc), end
        )

    # PyUnicodeEncodeError_GetObject
    @staticmethod
    def get_object(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicodeEncodeError_GetObject"], _deref_maybe(exc)
        )

    # PyUnicodeEncodeError_GetReason
    @staticmethod
    def get_reason(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicodeEncodeError_GetReason"], _deref_maybe(exc)
        )

    # PyUnicodeEncodeError_GetStart
    @staticmethod
    def get_start(exc: PyObjectLike, start: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeEncodeError_GetStart"], _deref_maybe(exc), start
        )

    # PyUnicodeEncodeError_SetEnd
    @staticmethod
    def set_end(exc: PyObjectLike, end: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeEncodeError_SetEnd"], _deref_maybe(exc), end
        )

    # PyUnicodeEncodeError_SetReason
    @staticmethod
    def set_reason(exc: PyObjectLike, reason: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeEncodeError_SetReason"],
            _deref_maybe(exc),
            make_string(reason),
        )

    # PyUnicodeEncodeError_SetStart
    @staticmethod
    def set_start(exc: PyObjectLike, start: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeEncodeError_SetStart"], _deref_maybe(exc), start
        )


class PyUnicodeTranslateError(_CallBase):
    """Namespace containing API functions prefixed with `PyUnicodeTranslateError_`"""

    # PyUnicodeTranslateError_GetEnd
    @staticmethod
    def get_end(exc: PyObjectLike, end: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeTranslateError_GetEnd"], _deref_maybe(exc), end
        )

    # PyUnicodeTranslateError_GetObject
    @staticmethod
    def get_object(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicodeTranslateError_GetObject"], _deref_maybe(exc)
        )

    # PyUnicodeTranslateError_GetReason
    @staticmethod
    def get_reason(exc: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicodeTranslateError_GetReason"], _deref_maybe(exc)
        )

    # PyUnicodeTranslateError_GetStart
    @staticmethod
    def get_start(exc: PyObjectLike, start: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeTranslateError_GetStart"], _deref_maybe(exc), start
        )

    # PyUnicodeTranslateError_SetEnd
    @staticmethod
    def set_end(exc: PyObjectLike, end: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeTranslateError_SetEnd"], _deref_maybe(exc), end
        )

    # PyUnicodeTranslateError_SetReason
    @staticmethod
    def set_reason(exc: PyObjectLike, reason: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeTranslateError_SetReason"],
            _deref_maybe(exc),
            make_string(reason),
        )

    # PyUnicodeTranslateError_SetStart
    @staticmethod
    def set_start(exc: PyObjectLike, start: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicodeTranslateError_SetStart"], _deref_maybe(exc), start
        )


class PyUnicode(_CallBase):
    """Namespace containing API functions prefixed with `PyUnicode_`"""

    # PyUnicode_AsASCIIString
    @staticmethod
    def as_ascii__string(unicode: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsASCIIString"], _deref_maybe(unicode)
        )

    # PyUnicode_AsCharmapString
    @staticmethod
    def as_charmap_string(unicode: PyObjectLike, mapping: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsCharmapString"],
            _deref_maybe(unicode),
            _deref_maybe(mapping),
        )

    # PyUnicode_AsEncodedString
    @staticmethod
    def as_encoded_string(
        unicode: PyObjectLike, encoding: StringLike, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsEncodedString"],
            _deref_maybe(unicode),
            make_string(encoding),
            make_string(errors),
        )

    # PyUnicode_AsLatin1String
    @staticmethod
    def as_latin1_string(unicode: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsLatin1String"], _deref_maybe(unicode)
        )

    # PyUnicode_AsRawUnicodeEscapeString
    @staticmethod
    def as_raw_unicode_escape_string(unicode: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsRawUnicodeEscapeString"], _deref_maybe(unicode)
        )

    # PyUnicode_AsUCS4
    @staticmethod
    def as_ucs_4(
        u: PyObjectLike, buffer: PointerLike, buflen: int, copy_null: int
    ) -> PointerLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsUCS4"], _deref_maybe(u), buffer, buflen, copy_null
        )

    # PyUnicode_AsUCS4Copy
    @staticmethod
    def as_ucs_4_copy(u: PyObjectLike) -> PointerLike:
        return api_binding_base(API_FUNCS["PyUnicode_AsUCS4Copy"], _deref_maybe(u))

    # PyUnicode_AsUTF16String
    @staticmethod
    def as_utf_16_string(unicode: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsUTF16String"], _deref_maybe(unicode)
        )

    # PyUnicode_AsUTF32String
    @staticmethod
    def as_utf_32_string(unicode: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsUTF32String"], _deref_maybe(unicode)
        )

    # PyUnicode_AsUTF8AndSize
    @staticmethod
    def as_utf_8_and_size(unicode: PyObjectLike, size: PointerLike) -> StringLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsUTF8AndSize"], _deref_maybe(unicode), size
        )

    # PyUnicode_AsUTF8String
    @staticmethod
    def as_utf_8_string(unicode: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsUTF8String"], _deref_maybe(unicode)
        )

    # PyUnicode_AsUnicodeEscapeString
    @staticmethod
    def as_unicode_escape_string(unicode: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsUnicodeEscapeString"], _deref_maybe(unicode)
        )

    # PyUnicode_AsWideChar
    @staticmethod
    def as_wide_char(unicode: PyObjectLike, w: str, size: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsWideChar"], _deref_maybe(unicode), w, size
        )

    # PyUnicode_AsWideCharString
    @staticmethod
    def as_wide_char_string(unicode: PyObjectLike, size: PointerLike) -> str:
        return api_binding_base(
            API_FUNCS["PyUnicode_AsWideCharString"], _deref_maybe(unicode), size
        )

    # PyUnicode_Compare
    @staticmethod
    def compare(left: PyObjectLike, right: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_Compare"], _deref_maybe(left), _deref_maybe(right)
        )

    # PyUnicode_CompareWithASCIIString
    @staticmethod
    def compare_with_ascii__string(uni: PyObjectLike, string: StringLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_CompareWithASCIIString"],
            _deref_maybe(uni),
            make_string(string),
        )

    # PyUnicode_Concat
    @staticmethod
    def concat(left: PyObjectLike, right: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_Concat"], _deref_maybe(left), _deref_maybe(right)
        )

    # PyUnicode_Contains
    @staticmethod
    def contains(container: PyObjectLike, element: PyObjectLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_Contains"],
            _deref_maybe(container),
            _deref_maybe(element),
        )

    # PyUnicode_Count
    @staticmethod
    def count(str: PyObjectLike, substr: PyObjectLike, start: int, end: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_Count"],
            _deref_maybe(str),
            _deref_maybe(substr),
            start,
            end,
        )

    # PyUnicode_Decode
    @staticmethod
    def decode(
        s: StringLike, size: int, encoding: StringLike, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_Decode"],
            make_string(s),
            size,
            make_string(encoding),
            make_string(errors),
        )

    # PyUnicode_DecodeASCII
    @staticmethod
    def decode_ascii(s: StringLike, size: int, errors: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeASCII"],
            make_string(s),
            size,
            make_string(errors),
        )

    # PyUnicode_DecodeCharmap
    @staticmethod
    def decode_charmap(
        data: StringLike, size: int, mapping: PyObjectLike, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeCharmap"],
            make_string(data),
            size,
            _deref_maybe(mapping),
            make_string(errors),
        )

    # PyUnicode_DecodeFSDefault
    @staticmethod
    def decode_fs__default(s: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyUnicode_DecodeFSDefault"], make_string(s))

    # PyUnicode_DecodeFSDefaultAndSize
    @staticmethod
    def decode_fs__default_and_size(s: StringLike, size: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeFSDefaultAndSize"], make_string(s), size
        )

    # PyUnicode_DecodeLatin1
    @staticmethod
    def decode_latin1(s: StringLike, size: int, errors: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeLatin1"],
            make_string(s),
            size,
            make_string(errors),
        )

    # PyUnicode_DecodeLocale
    @staticmethod
    def decode_locale(str: StringLike, errors: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeLocale"], make_string(str), make_string(errors)
        )

    # PyUnicode_DecodeLocaleAndSize
    @staticmethod
    def decode_locale_and_size(
        str: StringLike, len: int, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeLocaleAndSize"],
            make_string(str),
            len,
            make_string(errors),
        )

    # PyUnicode_DecodeRawUnicodeEscape
    @staticmethod
    def decode_raw_unicode_escape(
        s: StringLike, size: int, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeRawUnicodeEscape"],
            make_string(s),
            size,
            make_string(errors),
        )

    # PyUnicode_DecodeUTF16
    @staticmethod
    def decode_utf_16(
        s: StringLike, size: int, errors: StringLike, byteorder: PointerLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeUTF16"],
            make_string(s),
            size,
            make_string(errors),
            byteorder,
        )

    # PyUnicode_DecodeUTF16Stateful
    @staticmethod
    def decode_utf_16_stateful(
        s: StringLike,
        size: int,
        errors: StringLike,
        byteorder: PointerLike,
        consumed: PointerLike,
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeUTF16Stateful"],
            make_string(s),
            size,
            make_string(errors),
            byteorder,
            consumed,
        )

    # PyUnicode_DecodeUTF32
    @staticmethod
    def decode_utf_32(
        s: StringLike, size: int, errors: StringLike, byteorder: PointerLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeUTF32"],
            make_string(s),
            size,
            make_string(errors),
            byteorder,
        )

    # PyUnicode_DecodeUTF32Stateful
    @staticmethod
    def decode_utf_32_stateful(
        s: StringLike,
        size: int,
        errors: StringLike,
        byteorder: PointerLike,
        consumed: PointerLike,
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeUTF32Stateful"],
            make_string(s),
            size,
            make_string(errors),
            byteorder,
            consumed,
        )

    # PyUnicode_DecodeUTF7
    @staticmethod
    def decode_utf_7(s: StringLike, size: int, errors: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeUTF7"], make_string(s), size, make_string(errors)
        )

    # PyUnicode_DecodeUTF7Stateful
    @staticmethod
    def decode_utf_7_stateful(
        s: StringLike, size: int, errors: StringLike, consumed: PointerLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeUTF7Stateful"],
            make_string(s),
            size,
            make_string(errors),
            consumed,
        )

    # PyUnicode_DecodeUTF8
    @staticmethod
    def decode_utf_8(s: StringLike, size: int, errors: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeUTF8"], make_string(s), size, make_string(errors)
        )

    # PyUnicode_DecodeUTF8Stateful
    @staticmethod
    def decode_utf_8_stateful(
        s: StringLike, size: int, errors: StringLike, consumed: PointerLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeUTF8Stateful"],
            make_string(s),
            size,
            make_string(errors),
            consumed,
        )

    # PyUnicode_DecodeUnicodeEscape
    @staticmethod
    def decode_unicode_escape(
        s: StringLike, size: int, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_DecodeUnicodeEscape"],
            make_string(s),
            size,
            make_string(errors),
        )

    # PyUnicode_EncodeFSDefault
    @staticmethod
    def encode_fs__default(unicode: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_EncodeFSDefault"], _deref_maybe(unicode)
        )

    # PyUnicode_EncodeLocale
    @staticmethod
    def encode_locale(unicode: PyObjectLike, errors: StringLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_EncodeLocale"],
            _deref_maybe(unicode),
            make_string(errors),
        )

    # PyUnicode_FSConverter
    @staticmethod
    def fs__converter(obj: PyObjectLike, result: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_FSConverter"], _deref_maybe(obj), result
        )

    # PyUnicode_FSDecoder
    @staticmethod
    def fs__decoder(obj: PyObjectLike, result: PointerLike) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_FSDecoder"], _deref_maybe(obj), result
        )

    # PyUnicode_Find
    @staticmethod
    def find(
        str: PyObjectLike, substr: PyObjectLike, start: int, end: int, direction: int
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_Find"],
            _deref_maybe(str),
            _deref_maybe(substr),
            start,
            end,
            direction,
        )

    # PyUnicode_FindChar
    @staticmethod
    def find_char(
        str: PyObjectLike, ch: int, start: int, end: int, direction: int
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_FindChar"],
            _deref_maybe(str),
            ch,
            start,
            end,
            direction,
        )

    # PyUnicode_Format
    @staticmethod
    def format(format: PyObjectLike, args: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_Format"], _deref_maybe(format), _deref_maybe(args)
        )

    # PyUnicode_FromEncodedObject
    @staticmethod
    def from_encoded_object(
        obj: PyObjectLike, encoding: StringLike, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_FromEncodedObject"],
            _deref_maybe(obj),
            make_string(encoding),
            make_string(errors),
        )

    # PyUnicode_FromFormatV
    @staticmethod
    def from_format_v(format: StringLike, vargs: PointerLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_FromFormatV"], make_string(format), vargs
        )

    # PyUnicode_FromObject
    @staticmethod
    def from_object(obj: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyUnicode_FromObject"], _deref_maybe(obj))

    # PyUnicode_FromString
    @staticmethod
    def from_string(u: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyUnicode_FromString"], make_string(u))

    # PyUnicode_FromStringAndSize
    @staticmethod
    def from_string_and_size(u: StringLike, size: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_FromStringAndSize"], make_string(u), size
        )

    # PyUnicode_FromWideChar
    @staticmethod
    def from_wide_char(w: str, size: int) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyUnicode_FromWideChar"], w, size)

    # PyUnicode_GetLength
    @staticmethod
    def get_length(unicode: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyUnicode_GetLength"], _deref_maybe(unicode))

    # PyUnicode_GetSize
    @staticmethod
    def get_size(unicode: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyUnicode_GetSize"], _deref_maybe(unicode))

    # PyUnicode_InternFromString
    @staticmethod
    def intern_from_string(v: StringLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyUnicode_InternFromString"], make_string(v))

    # PyUnicode_InternInPlace
    @staticmethod
    def intern_in_place(string: PointerLike) -> None:
        return api_binding_base(API_FUNCS["PyUnicode_InternInPlace"], string)

    # PyUnicode_IsIdentifier
    @staticmethod
    def is_identifier(o: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["PyUnicode_IsIdentifier"], _deref_maybe(o))

    # PyUnicode_Join
    @staticmethod
    def join(separator: PyObjectLike, seq: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_Join"], _deref_maybe(separator), _deref_maybe(seq)
        )

    # PyUnicode_ReadChar
    @staticmethod
    def read_char(unicode: PyObjectLike, index: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_ReadChar"], _deref_maybe(unicode), index
        )

    # PyUnicode_Replace
    @staticmethod
    def replace(
        str: PyObjectLike, substr: PyObjectLike, replstr: PyObjectLike, maxcount: int
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_Replace"],
            _deref_maybe(str),
            _deref_maybe(substr),
            _deref_maybe(replstr),
            maxcount,
        )

    # PyUnicode_RichCompare
    @staticmethod
    def rich_compare(left: PyObjectLike, right: PyObjectLike, op: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_RichCompare"],
            _deref_maybe(left),
            _deref_maybe(right),
            op,
        )

    # PyUnicode_Split
    @staticmethod
    def split(s: PyObjectLike, sep: PyObjectLike, maxsplit: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_Split"], _deref_maybe(s), _deref_maybe(sep), maxsplit
        )

    # PyUnicode_Splitlines
    @staticmethod
    def splitlines(s: PyObjectLike, keepend: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_Splitlines"], _deref_maybe(s), keepend
        )

    # PyUnicode_Substring
    @staticmethod
    def substring(str: PyObjectLike, start: int, end: int) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_Substring"], _deref_maybe(str), start, end
        )

    # PyUnicode_Tailmatch
    @staticmethod
    def tailmatch(
        str: PyObjectLike, substr: PyObjectLike, start: int, end: int, direction: int
    ) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_Tailmatch"],
            _deref_maybe(str),
            _deref_maybe(substr),
            start,
            end,
            direction,
        )

    # PyUnicode_Translate
    @staticmethod
    def translate(
        str: PyObjectLike, table: PyObjectLike, errors: StringLike
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyUnicode_Translate"],
            _deref_maybe(str),
            _deref_maybe(table),
            make_string(errors),
        )

    # PyUnicode_WriteChar
    @staticmethod
    def write_char(unicode: PyObjectLike, index: int, character: int) -> int:
        return api_binding_base(
            API_FUNCS["PyUnicode_WriteChar"], _deref_maybe(unicode), index, character
        )


class PyWeakref(_CallBase):
    """Namespace containing API functions prefixed with `PyWeakref_`"""

    # PyWeakref_GetObject
    @staticmethod
    def get_object(ref: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["PyWeakref_GetObject"], _deref_maybe(ref))

    # PyWeakref_NewProxy
    @staticmethod
    def new_proxy(ob: PyObjectLike, callback: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyWeakref_NewProxy"], _deref_maybe(ob), _deref_maybe(callback)
        )

    # PyWeakref_NewRef
    @staticmethod
    def new_ref(ob: PyObjectLike, callback: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["PyWeakref_NewRef"], _deref_maybe(ob), _deref_maybe(callback)
        )


class Py(_CallBase):
    """Namespace containing API functions prefixed with `Py_`"""

    # Py_BytesMain
    @staticmethod
    def bytes_main(argc: int, argv: PointerLike) -> int:
        return api_binding_base(API_FUNCS["Py_BytesMain"], argc, argv)

    # Py_CompileString
    @staticmethod
    def compile_string(
        str: StringLike, filename: StringLike, start: int
    ) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["Py_CompileString"],
            make_string(str),
            make_string(filename),
            start,
        )

    # Py_DecRef
    @staticmethod
    def dec_ref(o: PyObjectLike) -> None:
        return api_binding_base(API_FUNCS["Py_DecRef"], _deref_maybe(o))

    # Py_DecodeLocale
    @staticmethod
    def decode_locale(arg: StringLike, size: PointerLike) -> str:
        return api_binding_base(API_FUNCS["Py_DecodeLocale"], make_string(arg), size)

    # Py_EncodeLocale
    @staticmethod
    def encode_locale(text: str, error_pos: PointerLike) -> StringLike:
        return api_binding_base(API_FUNCS["Py_EncodeLocale"], text, error_pos)

    # Py_EndInterpreter
    @staticmethod
    def end_interpreter(tstate: StructPointer[ThreadState]) -> None:
        return api_binding_base(API_FUNCS["Py_EndInterpreter"], tstate)

    # Py_EnterRecursiveCall
    @staticmethod
    def enter_recursive_call(where: StringLike) -> int:
        return api_binding_base(API_FUNCS["Py_EnterRecursiveCall"], make_string(where))

    # Py_Exit
    @staticmethod
    def exit(status: int) -> None:
        return api_binding_base(API_FUNCS["Py_Exit"], status)

    # Py_FatalError
    @staticmethod
    def fatal_error(message: StringLike) -> None:
        return api_binding_base(API_FUNCS["Py_FatalError"], make_string(message))

    # Py_Finalize
    @staticmethod
    def finalize() -> None:
        return api_binding_base(
            API_FUNCS["Py_Finalize"],
        )

    # Py_FinalizeEx
    @staticmethod
    def finalize_ex() -> int:
        return api_binding_base(
            API_FUNCS["Py_FinalizeEx"],
        )

    # Py_GenericAlias
    @staticmethod
    def generic_alias(origin: PyObjectLike, args: PyObjectLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["Py_GenericAlias"], _deref_maybe(origin), _deref_maybe(args)
        )

    # Py_GetBuildInfo
    @staticmethod
    def get_build_info() -> StringLike:
        return api_binding_base(
            API_FUNCS["Py_GetBuildInfo"],
        )

    # Py_GetCompiler
    @staticmethod
    def get_compiler() -> StringLike:
        return api_binding_base(
            API_FUNCS["Py_GetCompiler"],
        )

    # Py_GetCopyright
    @staticmethod
    def get_copyright() -> StringLike:
        return api_binding_base(
            API_FUNCS["Py_GetCopyright"],
        )

    # Py_GetExecPrefix
    @staticmethod
    def get_exec_prefix() -> str:
        return api_binding_base(
            API_FUNCS["Py_GetExecPrefix"],
        )

    # Py_GetPath
    @staticmethod
    def get_path() -> str:
        return api_binding_base(
            API_FUNCS["Py_GetPath"],
        )

    # Py_GetPlatform
    @staticmethod
    def get_platform() -> StringLike:
        return api_binding_base(
            API_FUNCS["Py_GetPlatform"],
        )

    # Py_GetPrefix
    @staticmethod
    def get_prefix() -> str:
        return api_binding_base(
            API_FUNCS["Py_GetPrefix"],
        )

    # Py_GetProgramFullPath
    @staticmethod
    def get_program_full_path() -> str:
        return api_binding_base(
            API_FUNCS["Py_GetProgramFullPath"],
        )

    # Py_GetProgramName
    @staticmethod
    def get_program_name() -> str:
        return api_binding_base(
            API_FUNCS["Py_GetProgramName"],
        )

    # Py_GetPythonHome
    @staticmethod
    def get_python_home() -> str:
        return api_binding_base(
            API_FUNCS["Py_GetPythonHome"],
        )

    # Py_GetVersion
    @staticmethod
    def get_version() -> StringLike:
        return api_binding_base(
            API_FUNCS["Py_GetVersion"],
        )

    # Py_IncRef
    @staticmethod
    def inc_ref(o: PyObjectLike) -> None:
        return api_binding_base(API_FUNCS["Py_IncRef"], _deref_maybe(o))

    # Py_Initialize
    @staticmethod
    def initialize() -> None:
        return api_binding_base(
            API_FUNCS["Py_Initialize"],
        )

    # Py_InitializeEx
    @staticmethod
    def initialize_ex(initsigs: int) -> None:
        return api_binding_base(API_FUNCS["Py_InitializeEx"], initsigs)

    # Py_Is
    @staticmethod
    def is_(x: PyObjectLike, y: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["Py_Is"], _deref_maybe(x), _deref_maybe(y))

    # Py_IsFalse
    @staticmethod
    def is_false(x: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["Py_IsFalse"], _deref_maybe(x))

    # Py_IsInitialized
    @staticmethod
    def is_initialized() -> int:
        return api_binding_base(
            API_FUNCS["Py_IsInitialized"],
        )

    # Py_IsNone
    @staticmethod
    def is_none(x: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["Py_IsNone"], _deref_maybe(x))

    # Py_IsTrue
    @staticmethod
    def is_true(x: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["Py_IsTrue"], _deref_maybe(x))

    # Py_LeaveRecursiveCall
    @staticmethod
    def leave_recursive_call() -> None:
        return api_binding_base(
            API_FUNCS["Py_LeaveRecursiveCall"],
        )

    # Py_Main
    @staticmethod
    def main(argc: int, argv: PointerLike) -> int:
        return api_binding_base(API_FUNCS["Py_Main"], argc, argv)

    # Py_NewInterpreter
    @staticmethod
    def new_interpreter() -> StructPointer[ThreadState]:
        return api_binding_base(
            API_FUNCS["Py_NewInterpreter"],
        )

    # Py_NewRef
    @staticmethod
    def new_ref(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["Py_NewRef"], _deref_maybe(o))

    # Py_ReprEnter
    @staticmethod
    def repr_enter(object: PyObjectLike) -> int:
        return api_binding_base(API_FUNCS["Py_ReprEnter"], _deref_maybe(object))

    # Py_ReprLeave
    @staticmethod
    def repr_leave(object: PyObjectLike) -> None:
        return api_binding_base(API_FUNCS["Py_ReprLeave"], _deref_maybe(object))

    # Py_SetProgramName
    @staticmethod
    def set_program_name(name: str) -> None:
        return api_binding_base(API_FUNCS["Py_SetProgramName"], name)

    # Py_SetPythonHome
    @staticmethod
    def set_python_home(home: str) -> None:
        return api_binding_base(API_FUNCS["Py_SetPythonHome"], home)

    # Py_VaBuildValue
    @staticmethod
    def va_build_value(format: StringLike, vargs: PointerLike) -> PyObjectLike:
        return api_binding_base(
            API_FUNCS["Py_VaBuildValue"], make_string(format), vargs
        )

    # Py_XNewRef
    @staticmethod
    def x_new_ref(o: PyObjectLike) -> PyObjectLike:
        return api_binding_base(API_FUNCS["Py_XNewRef"], _deref_maybe(o))
